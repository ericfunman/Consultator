"""
Service Chatbot pour interroger les donn√©es des consultants
Utilise l'IA pour r√©pondre aux questions sur la base de donn√©es
"""

import json
import re
from datetime import datetime
from typing import Any
from typing import Dict
from typing import List
from typing import Optional

import streamlit as st
from sqlalchemy import and_
from sqlalchemy import func
from sqlalchemy import or_
from sqlalchemy.exc import SQLAlchemyError

# Imports des services existants
from database.database import get_database_session
from database.models import Competence
from database.models import Consultant
from database.models import ConsultantCompetence
from database.models import ConsultantLangue
from database.models import Langue
from database.models import Mission


class ChatbotService:
    """Service principal du chatbot pour Consultator"""

    # Constantes pour les cha√Ænes de format r√©p√©t√©es
    SECTION_HEADER_SUFFIX = "** :\n\n"
    YEARS_SUFFIX = " ann√©es\n"
    TOTAL_PREFIX = "\nüìä **Total : "
    CONSULTANT_FOUND_SUFFIX = " consultant(s) trouv√©(s)**"
    STATS_PREFIX = "\n\nüìä **"
    BULLET_POINT = " ‚Ä¢ "
    BULLET_POINT_INDENT = "   ‚Ä¢ "
    DATE_FORMAT = "%d/%m/%Y"

    def __init__(self):
        # Suppression de la session partag√©e pour √©viter les timeouts
        # Chaque m√©thode utilisera une session fra√Æche via context manager
        self.conversation_history = []
        self.last_question = ""

    def _get_session(self):
        """
        Retourne une session de base de donn√©es fra√Æche
        Utilis√© pour √©viter les timeouts de session apr√®s inactivit√©
        """
        return get_database_session()

    def _execute_with_fresh_session(self, query_func):
        """
        Ex√©cute une fonction de requ√™te avec une session fra√Æche
        Args:
            query_func: Fonction qui prend une session en param√®tre et retourne un r√©sultat
        """
        try:
            with get_database_session() as session:
                return query_func(session)
        except Exception as e:
            print(f"Erreur de session dans le chatbot: {e}")
            # Retry avec une nouvelle session
            with get_database_session() as session:
                return query_func(session)

    def _route_question_to_handler(self, intent: str, entities: dict) -> Dict[str, Any]:
        """Route la question vers le bon handler selon l'intention"""
        if intent == "salaire":
            return self._handle_salary_question(entities)
        elif intent == "experience":
            return self._handle_experience_question(entities)
        elif intent == "profil_professionnel":
            return self._handle_professional_profile_question(entities)
        elif intent == "competences":
            return self._handle_skills_question(entities)
        elif intent == "langues":
            return self._handle_languages_question(entities)
        elif intent == "missions":
            return self._handle_missions_question(entities)
        elif intent == "contact":
            return self._handle_contact_question(entities)
        elif intent == "liste_consultants":
            return self._handle_list_consultants_question()
        elif intent == "practices":
            return self._handle_practices_question(entities)
        elif intent == "cvs":
            return self._handle_cvs_question(entities)
        elif intent == "statistiques":
            return self._handle_stats_question()
        elif intent == "disponibilite":  # Nouveau handler V1.2.2
            return self._handle_availability_question(entities)
        elif intent == "tjm_mission":  # Nouveau handler V1.2.2
            return self._handle_mission_tjm_question(entities)
        elif intent == "recherche_consultant":
            return self._handle_consultant_search(entities)
        else:
            return self._handle_general_question()

    def process_question(self, question: str) -> Dict[str, Any]:
        """
        Traite une question et retourne une r√©ponse structur√©e

        Args:
            question: Question de l'utilisateur

        Returns:
            Dict contenant la r√©ponse, les donn√©es et m√©tadonn√©es
        """
        try:
            # Nettoyer et analyser la question
            clean_question = self._clean_question(question)
            self.last_question = clean_question  # Stocker pour usage dans les handlers
            intent = self._analyze_intent(clean_question)
            entities = self._extract_entities(clean_question)

            # Router vers le bon handler
            return self._route_question_to_handler(intent, entities)

        except Exception as e:
            return {
                "response": f"‚ùå D√©sol√©, j'ai rencontr√© une erreur : {str(e)}",
                "data": None,
                "intent": "error",
                "confidence": 0.0,
            }

    def _clean_question(self, question: str) -> str:
        """Nettoie et normalise la question"""
        # Supprimer la ponctuation excessive
        question = re.sub(r"!{2,}", "!", question)
        question = re.sub(r"\?{2,}", "?", question)

        # Normaliser les espaces
        question = re.sub(r"\s+", " ", question.strip())

        return question.lower()

    def _check_consultant_name_mentioned(self, question: str) -> bool:
        """V√©rifie si un nom de consultant est mentionn√© dans la question"""
        with get_database_session() as session:
            all_consultants = session.query(Consultant).all()
            for consultant in all_consultants:
                if re.search(
                    rf"\b{re.escape(consultant.prenom.lower())}\b", question
                ) or re.search(rf"\b{re.escape(consultant.nom.lower())}\b", question):
                    return True
            return False

    def _get_intent_patterns(self) -> Dict[str, List[str]]:
        """Retourne les patterns pour identifier les intentions"""
        return {
            "salaire": [
                r"salaire",
                r"r√©mun√©ration",
                r"paie",
                r"combien gagne",
                r"revenus",
                r"euros",
                r"‚Ç¨",
                r"salaire de",
                r"gagne",
                r"cjm",
                r"co√ªt journalier",
            ],
            "experience": [
                r"exp√©rience",
                r"experience",
                r"ann√©es d'exp√©rience",
                r"annees d'experience",
                r"anciennet√©",
                r"seniorit√©",
                r"s√©niorit√©",
                r"depuis quand",
                r"depuis combien",
                r"combien d'ann√©es",
                r"combien d'annees",
                r"quel √¢ge",
                r"√¢ge professionnel",
            ],
            "profil_professionnel": [
                r"grade",
                r"niveau",
                r"poste",
                r"fonction",
                r"junior",
                r"confirm√©",
                r"senior",
                r"manager",
                r"directeur",
                r"type contrat",
                r"type de contrat",
                r"contrat",
                r"cdi",
                r"cdd",
                r"stagiaire",
                r"alternant",
                r"ind√©pendant",
                r"freelance",
                r"soci√©t√©",
                r"societe",
                r"quanteam",
                r"asigma",
                r"entreprise",
            ],
            "competences": [
                r"comp√©tences",
                r"competences",
                r"ma√Ætrise",
                r"maitrise",
                r"sait faire",
                r"technologies",
                r"langages",
                r"outils",
                r"expertise",
                r"python",
                r"sql",
                r"java",
                r"quelles.+comp√©tences",
                r"quelles.+competences",
                r"skills",
                r"techno",
                r"conna√Æt",
                r"connait",
            ],
            "langues": [
                r"langues?",
                r"langue",
                r"parle",
                r"parlent",
                r"anglais",
                r"fran√ßais",
                r"espagnol",
                r"allemand",
                r"italien",
                r"bilingue",
                r"niveau.+langue",
                r"parle.+anglais",
                r"qui.+parle",
                r"quelles.+langues",
                r"polyglotte",
                r"linguistique",
            ],
            "missions": [
                r"missions",
                r"mission",
                r"travaille",
                r"chez",
                r"entreprise",
                r"client",
                r"projet",
                r"bnp",
                r"paribas",
                r"soci√©t√© g√©n√©rale",
                r"combien.+missions?",
                r"nombre.+missions?",
                r"projets",
            ],
            "contact": [
                r"mail",
                r"email",
                r"e-mail",
                r"t√©l√©phone",
                r"tel",
                r"num√©ro",
                r"contact",
                r"joindre",
                r"coordonn√©es",
            ],
            "liste_consultants": [
                r"quels sont les consultants",
                r"liste des consultants",
                r"consultants disponibles",
                r"consultants actifs",
                r"tous les consultants",
                r"lister les consultants",
                r"qui sont les consultants",
                r"montrer les consultants",
            ],
            "practices": [
                r"practice",
                r"practices",
                r"qui est dans la practice",
                r"consultants de la practice",
                r"practice data",
                r"practice quant",
                r"√©quipe",
                r"dans quelle practice",
            ],
            "cvs": [
                r"cv",
                r"curriculum",
                r"document",
                r"fichier",
                r"upload",
                r"t√©l√©charg√©",
            ],
            "statistiques": [
                r"combien.+consultants",
                r"nombre.+consultants",
                r"combien.+dans.+base",
                r"nombre",
                r"moyenne",
                r"total",
                r"statistiques",
                r"combien.+missions",
                r"actifs",
                r"inactifs",
                r"tjm moyen",
                r"combien y a",
                r"il y a combien",
            ],
            "disponibilite": [  # Nouvelle intention V1.2.2
                r"disponible",
                r"disponibilit√©",
                r"libre",
                r"quand.+libre",
                r"quand.+disponible",
                r"date.+disponibilit√©",
                r"fin.+mission",
                r"lib√©r√©",
                r"fini",
                r"termine",
                r"asap",
                r"imm√©diatement",
                r"tout de suite",
                r"prochaine disponibilit√©",
            ],
            "tjm_mission": [  # Nouvelle intention V1.2.2
                r"tjm.+mission",
                r"taux.+mission",
                r"prix.+mission",
                r"co√ªt.+mission",
                r"tarif.+mission",
                r"facturation.+mission",
                r"journalier.+mission",
                r"combien.+co√ªte.+mission",
                r"prix.+journ√©e.+mission",
                r"tjm mission",
                r"prix mission",
                r"co√ªt mission",
                r"tarif mission",
                r"taux journalier mission",
                r"combien co√ªte mission",
            ],
            "recherche_consultant": [
                r"qui est",
                r"consultant",
                r"profil",
                r"information sur",
                r"details",
            ],
        }

    def _calculate_intent_scores(self, question: str, intent_patterns: Dict[str, List[str]]) -> Dict[str, int]:
        """Calcule les scores pour chaque intention"""
        intent_scores: Dict[str, int] = {}
        for intent, patterns in intent_patterns.items():
            score: int = 0
            for pattern in patterns:
                if re.search(pattern, question):
                    score += 1
            intent_scores[intent] = score
        return intent_scores

    def _apply_special_intent_rules(self, question: str, intent_scores: Dict[str, int], has_consultant_name: bool) -> Optional[str]:
        """Applique les r√®gles sp√©ciales pour d√©terminer l'intention"""
        # Si un nom de consultant est mentionn√© et qu'on parle de salaire,
        # c'est forc√©ment une question de salaire sp√©cifique
        if has_consultant_name and intent_scores.get("salaire", 0) > 0:
            return "salaire"

        # Si un nom de consultant est mentionn√© et qu'on demande des coordonn√©es,
        # c'est forc√©ment une question de contact
        if has_consultant_name and intent_scores.get("contact", 0) > 0:
            return "contact"

        # NOUVELLE R√àGLE V1.2.2 : Prioriser tjm_mission sur missions si TJM est
        # mentionn√©
        if intent_scores.get("tjm_mission", 0) > 0 and re.search(
            r"tjm|taux|prix|co√ªt|tarif", question
        ):
            return "tjm_mission"

        # Si un nom de consultant est mentionn√© et qu'on parle de missions,
        # c'est forc√©ment une question de missions sp√©cifique
        if has_consultant_name and intent_scores.get("missions", 0) > 0:
            return "missions"

        # Si c'est une question de type "combien de consultants en CDI/CDD", c'est
        # du profil professionnel
        if re.search(
            r"combien.+(consultants?).+(cdi|cdd|stagiaire|alternant|ind√©pendant)",
            question,
        ):
            return "profil_professionnel"

        # Si c'est une question de type "qui travaille chez", c'est du profil
        # professionnel
        if re.search(r"qui.+(travaille|est).+(chez|dans).+(quanteam|asigma)", question):
            return "profil_professionnel"

        # Si c'est une question de type "combien de missions", c'est des missions
        if re.search(r"combien.+missions?", question):
            return "missions"

        # Si le mot "combien" est utilis√© avec un nom de consultant, c'est probablement un salaire
        # MAIS seulement si ce n'est pas d√©j√† trait√© par les r√®gles ci-dessus
        if has_consultant_name and re.search(r"combien", question):
            return "salaire"

        # Si c'est une question de type "combien de consultants", c'est des statistiques
        if re.search(r"combien.+(consultants?|dans.+base)", question):
            return "statistiques"

        return None

    def _analyze_intent(self, question: str) -> str:
        """Analyse l'intention de la question"""

        # D'abord, v√©rifier s'il y a un nom de consultant mentionn√©
        has_consultant_name = self._check_consultant_name_mentioned(question)

        # Patterns pour identifier les intentions
        intent_patterns = self._get_intent_patterns()

        # Scorer chaque intention
        intent_scores = self._calculate_intent_scores(question, intent_patterns)

        # Appliquer les r√®gles sp√©ciales
        special_intent = self._apply_special_intent_rules(question, intent_scores, has_consultant_name)
        if special_intent:
            return special_intent

        # Retourner l'intention avec le meilleur score
        if max(intent_scores.values()) > 0:
            best_intent = max(intent_scores, key=lambda k: intent_scores[k])
            return best_intent
        else:
            return "general"

    def _extract_consultant_names(self, question: str) -> List[str]:
        """Extrait les noms de consultants de la question"""
        noms = []
        with get_database_session() as session:
            all_consultants = session.query(Consultant).all()
        
        for consultant in all_consultants:
            # Chercher le pr√©nom dans la question (insensible √† la casse)
            if re.search(rf"\b{re.escape(consultant.prenom.lower())}\b", question):
                noms.append(consultant.prenom)
            # Chercher le nom de famille dans la question
            if re.search(rf"\b{re.escape(consultant.nom.lower())}\b", question):
                noms.append(consultant.nom)
            # Chercher le nom complet
            nom_complet: str = f"{consultant.prenom} {consultant.nom}".lower()
            if nom_complet in question:
                noms.append(f"{consultant.prenom} {consultant.nom}")
        
        # Supprimer les doublons en gardant l'ordre
        return list(dict.fromkeys(noms))

    def _extract_companies(self, question: str) -> List[str]:
        """Extrait les noms d'entreprises de la question"""
        entreprises = []
        entreprises_connues: List[str] = [
            "bnp paribas",
            "soci√©t√© g√©n√©rale",
            "axa",
            "orange",
            "airbus",
            "renault",
            "peugeot",
            "total",
            "carrefour",
            "cr√©dit agricole",
        ]
        for entreprise in entreprises_connues:
            if entreprise in question:
                entreprises.append(entreprise)
        return entreprises

    def _extract_skills(self, question: str) -> List[str]:
        """Extrait les comp√©tences de la question"""
        from database.models import Competence

        competences = []
        
        # Comp√©tences techniques pr√©d√©finies
        competences_connues: List[str] = [
            "python",
            "java",
            "javascript",
            "sql",
            "react",
            "angular",
            "node.js",
            "docker",
            "kubernetes",
            "aws",
            "azure",
            "power bi",
            "agile",
            "scrum",
            "finance",
            "devops",
        ]
        for competence in competences_connues:
            if competence in question:
                competences.append(competence)

        # Chercher aussi dans la base de donn√©es des comp√©tences
        with get_database_session() as session:
            all_competences = session.query(Competence).all()
        for competence in all_competences:
            if re.search(rf"\b{re.escape(competence.nom.lower())}\b", question):
                competences.append(competence.nom)

        # Supprimer les doublons
        return list(dict.fromkeys(competences))

    def _extract_languages(self, question: str) -> List[str]:
        """Extrait les langues de la question"""
        langues = []
        
        # Langues pr√©d√©finies
        langues_connues: List[str] = [
            "fran√ßais",
            "anglais",
            "espagnol",
            "allemand",
            "italien",
            "portugais",
            "chinois",
            "japonais",
            "arabe",
            "russe",
        ]

        # Chercher d'abord dans les langues pr√©d√©finies
        for langue in langues_connues:
            if langue in question:
                langues.append(langue)

        # Chercher dans la base de donn√©es
        with get_database_session() as session:
            all_langues = session.query(Langue).all()
        for langue in all_langues:
            if re.search(rf"\b{re.escape(langue.nom.lower())}\b", question):
                langues.append(langue.nom)

        # Supprimer les doublons
        return list(dict.fromkeys(langues))

    def _extract_amounts(self, question: str) -> List[str]:
        """Extrait les montants de la question"""
        montants_pattern: str = r"(\d+(?:\s*\d{3})*)\s*(?:euros?|‚Ç¨)"
        montants_matches: List[str] = re.findall(montants_pattern, question)
        return [montant.replace(" ", "") for montant in montants_matches]

    def _extract_practices(self, question: str) -> List[str]:
        """Extrait les practices de la question"""
        from database.models import Practice

        practices = []
        with get_database_session() as session:
            all_practices = session.query(Practice).filter(Practice.actif).all()
        for practice in all_practices:
            if re.search(rf"\b{re.escape(practice.nom.lower())}\b", question):
                practices.append(practice.nom)
        return practices

    def _extract_entities(self, question: str) -> Dict[str, List[str]]:
        """Extrait les entit√©s nomm√©es de la question"""
        return {
            "noms": self._extract_consultant_names(question),
            "entreprises": self._extract_companies(question),
            "competences": self._extract_skills(question),
            "langues": self._extract_languages(question),
            "montants": self._extract_amounts(question),
            "practices": self._extract_practices(question),
        }

        return entities

    def _calculate_cjm(self, salaire: float) -> float:
        """Calcule le CJM (Co√ªt Journalier Moyen) √† partir du salaire"""
        return salaire * 1.8 / 216

    def _format_salary_response(self, consultant, is_cjm_question: bool) -> str:
        """Formate la r√©ponse pour un consultant sp√©cifique selon le type de question"""
        if consultant.salaire_actuel and consultant.salaire_actuel > 0:
            if is_cjm_question:
                # Calculer le CJM
                cjm = self._calculate_cjm(consultant.salaire_actuel)
                response = (
                    "üìà Le CJM (Co√ªt Journalier Moyen) de **"
                    + consultant.prenom
                    + " "
                    + consultant.nom
                    + "** est de **"
                    + f"{cjm:,.0f}"
                    + " ‚Ç¨**."
                )
                response += f"\nüí° Calcul : {consultant.salaire_actuel:,.0f} ‚Ç¨ √ó 1.8 √∑ 216 = {cjm:,.0f} ‚Ç¨"
            else:
                response = (
                    "üí∞ Le salaire de **"
                    + consultant.prenom
                    + " "
                    + consultant.nom
                    + "** est de **"
                    + f"{consultant.salaire_actuel:,.0f}"
                    + " ‚Ç¨** par an."
                )

            if not consultant.disponibilite:
                response += "\n‚ö†Ô∏è Attention : ce consultant est actuellement indisponible."
        else:
            if is_cjm_question:
                response = f"‚ùì D√©sol√©, le CJM de **{consultant.prenom} {consultant.nom}** ne peut pas √™tre calcul√© car le salaire n'est pas renseign√©."
            else:
                response = f"‚ùì D√©sol√©, le salaire de **{consultant.prenom} {consultant.nom}** n'est pas renseign√© dans la base."
        
        return response

    def _handle_consultant_salary_inquiry(self, consultant, is_cjm_question: bool) -> Dict[str, Any]:
        """G√®re la r√©ponse pour un consultant sp√©cifique"""
        response = self._format_salary_response(consultant, is_cjm_question)
        
        return {
            "response": response,
            "data": {
                "consultant": {
                    "nom": consultant.nom,
                    "prenom": consultant.prenom,
                    "salaire": consultant.salaire_actuel,
                    "cjm": (
                        self._calculate_cjm(consultant.salaire_actuel)
                        if consultant.salaire_actuel
                        else None
                    ),
                    "disponibilite": consultant.disponibilite,
                }
            },
            "intent": "salaire",
            "confidence": 0.9,
        }

    def _handle_general_salary_stats(self) -> Dict[str, Any]:
        """G√®re les statistiques g√©n√©rales de salaire"""
        stats = self._get_salary_stats()
        response = f"""üìä **Statistiques des salaires :**

‚Ä¢ Salaire moyen : **{stats['moyenne']:,.0f} ‚Ç¨**
‚Ä¢ Salaire m√©dian : **{stats['mediane']:,.0f} ‚Ç¨**
‚Ä¢ Salaire minimum : **{stats['minimum']:,.0f} ‚Ç¨**
‚Ä¢ Salaire maximum : **{stats['maximum']:,.0f} ‚Ç¨**
‚Ä¢ Nombre de consultants : **{stats['total']}**"""

        return {
            "response": response,
            "data": {"stats": stats},
            "intent": "salaire",
            "confidence": 0.8,
        }

    def _handle_salary_question(self, entities: Dict) -> Dict[str, Any]:
        """G√®re les questions sur les salaires et le CJM"""

        # D√©tecter si c'est une question sur le CJM
        is_cjm_question = (
            "cjm" in self.last_question.lower()
            or "co√ªt journalier" in self.last_question.lower()
        )

        # Si un nom est mentionn√©, chercher ce consultant sp√©cifique
        if entities["noms"]:
            nom_recherche: str = entities["noms"][0]
            consultant = self._find_consultant_by_name(nom_recherche)

            if consultant:
                return self._handle_consultant_salary_inquiry(consultant, is_cjm_question)
            else:
                return {
                    "response": f"‚ùå Je n'ai pas trouv√© de consultant nomm√© **{nom_recherche}** dans la base de donn√©es.",
                    "data": None,
                    "intent": "salaire",
                    "confidence": 0.7,
                }

        # Sinon, donner des statistiques g√©n√©rales
        else:
            return self._handle_general_salary_stats()

    def _calculate_company_seniority(self, consultant_db) -> float:
        """Calcule l'anciennet√© dans la soci√©t√© en ann√©es"""
        from datetime import date
        
        if not consultant_db.date_entree_societe:
            return 0
        
        today = date.today()
        if consultant_db.date_sortie_societe:
            fin_periode = consultant_db.date_sortie_societe
        else:
            fin_periode = today
        delta_societe = fin_periode - consultant_db.date_entree_societe
        return round(delta_societe.days / 365.25, 1)

    def _format_experience_details(self, consultant, consultant_db) -> str:
        """Formate les d√©tails d'exp√©rience d'un consultant"""
        experience_annees = consultant_db.experience_annees
        
        response = (
            "üìä **Exp√©rience de "
            + consultant.prenom
            + " "
            + consultant.nom
            + self.SECTION_HEADER_SUFFIX
        )
        response += f"üöÄ **Premi√®re mission :** {consultant_db.date_premiere_mission.strftime(self.DATE_FORMAT)}\n"
        response += f"‚è±Ô∏è **Exp√©rience totale :** **{experience_annees} ann√©es**\n"

        # Ajouter des informations contextuelles
        if consultant_db.grade:
            response += f"üéØ **Grade actuel :** {consultant_db.grade}\n"

        if consultant_db.societe:
            response += f"üè¢ **Soci√©t√© :** {consultant_db.societe}\n"

        if consultant_db.date_entree_societe:
            response += f"üìÖ **Date d'entr√©e soci√©t√© :** {consultant_db.date_entree_societe.strftime(self.DATE_FORMAT)}\n"
            # Calculer l'anciennet√© dans la soci√©t√©
            anciennete_societe = self._calculate_company_seniority(consultant_db)
            response += f"üè¢ **Anciennet√© soci√©t√© :** {anciennete_societe} ann√©es\n"

        # Statut soci√©t√©
        statut = consultant_db.statut_societe
        if statut == "En poste":
            response += f"‚úÖ **Statut :** {statut}"
        elif statut == "D√©part pr√©vu":
            response += f"‚ö†Ô∏è **Statut :** {statut}"
        else:
            response += f"‚ùå **Statut :** {statut}"
        
        return response

    def _build_consultant_experience_data(self, consultant, consultant_db) -> Dict:
        """Construit les donn√©es structur√©es d'exp√©rience d'un consultant"""
        return {
            "nom": consultant.nom,
            "prenom": consultant.prenom,
            "experience_annees": (
                getattr(consultant_db, "experience_annees", None)
                if consultant_db
                else None
            ),
            "date_premiere_mission": (
                consultant_db.date_premiere_mission.isoformat()
                if consultant_db and consultant_db.date_premiere_mission
                else None
            ),
            "grade": (
                getattr(consultant_db, "grade", None)
                if consultant_db
                else None
            ),
            "societe": (
                getattr(consultant_db, "societe", None)
                if consultant_db
                else None
            ),
        }

    def _handle_consultant_experience_inquiry(self, consultant) -> Dict[str, Any]:
        """G√®re les questions d'exp√©rience pour un consultant sp√©cifique"""
        try:
            with get_database_session() as session:
                consultant_db = (
                    session.query(Consultant)
                    .filter(Consultant.id == consultant.id)
                    .first()
                )

                if consultant_db:
                    if consultant_db.date_premiere_mission:
                        response = self._format_experience_details(consultant, consultant_db)
                    else:
                        response = f"‚ùì L'exp√©rience de **{consultant.prenom} {consultant.nom}** ne peut pas √™tre calcul√©e car la date de premi√®re mission n'est pas renseign√©e."
                else:
                    response = f"‚ùå Impossible de r√©cup√©rer les donn√©es de **{consultant.prenom} {consultant.nom}**."

        except (ValueError, TypeError, AttributeError, KeyError) as e:
            response = f"‚ùå Erreur lors de la r√©cup√©ration des donn√©es d'exp√©rience : {str(e)}"
            consultant_db = None

        return {
            "response": response,
            "data": {"consultant": self._build_consultant_experience_data(consultant, consultant_db)},
            "intent": "experience",
            "confidence": 0.9,
        }

    def _calculate_experience_statistics(self, consultants_avec_experience) -> str:
        """Calcule et formate les statistiques d'exp√©rience g√©n√©rales"""
        experiences = [c.experience_annees for c in consultants_avec_experience]

        response = "üìä **Statistiques d'exp√©rience :**\n\n"
        response += f"‚Ä¢ **Consultants avec exp√©rience renseign√©e :** {len(consultants_avec_experience)}\n"
        response += (
            "‚Ä¢ **Exp√©rience moyenne :** "
            + str(sum(experiences) / len(experiences))
            + self.YEARS_SUFFIX
        )
        response += (
            "‚Ä¢ **Exp√©rience minimum :** "
            + str(min(experiences))
            + self.YEARS_SUFFIX
        )
        response += (
            "‚Ä¢ **Exp√©rience maximum :** "
            + str(max(experiences))
            + self.YEARS_SUFFIX
        )

        # Top 3 des plus exp√©riment√©s
        top_experienced = sorted(
            consultants_avec_experience,
            key=lambda c: c.experience_annees,
            reverse=True,
        )[:3]
        response += "\nüèÜ **Top 3 des plus exp√©riment√©s :**\n"
        for i, consultant in enumerate(top_experienced, 1):
            response += (
                str(i)
                + ". **"
                + consultant.prenom
                + " "
                + consultant.nom
                + "** : "
                + str(consultant.experience_annees)
                + self.YEARS_SUFFIX
            )
        
        return response

    def _handle_general_experience_stats(self) -> Dict[str, Any]:
        """G√®re les statistiques g√©n√©rales d'exp√©rience"""
        try:
            with get_database_session() as session:
                consultants_avec_experience = (
                    session.query(Consultant)
                    .filter(Consultant.date_premiere_mission.isnot(None))
                    .all()
                )

                if consultants_avec_experience:
                    response = self._calculate_experience_statistics(consultants_avec_experience)
                else:
                    response = "‚ùì Aucun consultant n'a d'exp√©rience renseign√©e dans la base."

        except (
            SQLAlchemyError,
            OSError,
            ValueError,
            TypeError,
            AttributeError,
            KeyError,
        ) as e:
            response = f"‚ùå Erreur lors du calcul des statistiques : {str(e)}"
            consultants_avec_experience = []

        return {
            "response": response,
            "data": {"consultants_count": len(consultants_avec_experience)},
            "intent": "experience",
            "confidence": 0.8,
        }

    def _handle_experience_question(self, entities: Dict) -> Dict[str, Any]:
        """G√®re les questions sur l'exp√©rience des consultants"""

        # Si un nom est mentionn√©, chercher ce consultant sp√©cifique
        if entities["noms"]:
            nom_recherche: str = entities["noms"][0]
            consultant = self._find_consultant_by_name(nom_recherche)

            if consultant:
                return self._handle_consultant_experience_inquiry(consultant)
            else:
                return {
                    "response": f"‚ùå Je n'ai pas trouv√© de consultant nomm√© **{nom_recherche}** dans la base de donn√©es.",
                    "data": None,
                    "intent": "experience",
                    "confidence": 0.7,
                }

        # Statistiques g√©n√©rales sur l'exp√©rience
        else:
            return self._handle_general_experience_stats()

    def _get_profile_response_for_grade(self, consultant, consultant_db):
        """Retourne la r√©ponse pour une question sur le grade"""
        return f"üéØ **Grade de {consultant.prenom} {consultant.nom}** : **{consultant_db.grade or 'Non renseign√©'}**"

    def _get_profile_response_for_contract(self, consultant, consultant_db):
        """Retourne la r√©ponse pour une question sur le type de contrat"""
        return f"üìã **Type de contrat de {consultant.prenom} {consultant.nom}** : **{consultant_db.type_contrat or 'Non renseign√©'}**"

    def _get_profile_response_for_company(self, consultant, consultant_db):
        """Retourne la r√©ponse pour une question sur la soci√©t√©"""
        response = f"üè¢ **Soci√©t√© de {consultant.prenom} {consultant.nom}** : **{consultant_db.societe or 'Non renseign√©'}**"
        if consultant_db.date_entree_societe:
            response += f"\nüìÖ **Date d'entr√©e :** {consultant_db.date_entree_societe.strftime(self.DATE_FORMAT)}"
        if consultant_db.date_sortie_societe:
            response += f"\nüìÖ **Date de sortie :** {consultant_db.date_sortie_societe.strftime(self.DATE_FORMAT)}"
        else:
            response += "\n‚úÖ **Toujours en poste**"
        return response

    def _get_complete_profile_response(self, consultant, consultant_db):
        """Retourne le profil professionnel complet"""
        response = f"üëî **Profil professionnel de {consultant.prenom} {consultant.nom}{self.SECTION_HEADER_SUFFIX}"
        response += f"üéØ **Grade :** {consultant_db.grade or 'Non renseign√©'}\n"
        response += f"üìã **Type de contrat :** {consultant_db.type_contrat or 'Non renseign√©'}\n"
        response += f"üè¢ **Soci√©t√© :** {consultant_db.societe or 'Non renseign√©'}\n"

        if consultant_db.date_entree_societe:
            response += f"üìÖ **Date d'entr√©e soci√©t√© :** {consultant_db.date_entree_societe.strftime(self.DATE_FORMAT)}\n"

        if consultant_db.date_sortie_societe:
            response += f"üìÖ **Date de sortie soci√©t√© :** {consultant_db.date_sortie_societe.strftime(self.DATE_FORMAT)}\n"
        else:
            response += "‚úÖ **Statut :** Toujours en poste\n"

        if consultant_db.experience_annees:
            response += f"‚è±Ô∏è **Exp√©rience :** {consultant_db.experience_annees}{self.YEARS_SUFFIX}"

        # Informations salariales si disponibles
        if consultant_db.salaire_actuel:
            cjm = consultant_db.salaire_actuel * 1.8 / 216
            response += f"üí∞ **Salaire :** {consultant_db.salaire_actuel:,.0f} ‚Ç¨/an\n"
            response += f"üìà **CJM :** {cjm:,.0f} ‚Ç¨/jour"

        return response

    def _handle_individual_profile_question(
        self, entities: Dict, question_lower: str
    ) -> Dict[str, Any]:
        """G√®re les questions de profil pour un consultant sp√©cifique"""
        nom_recherche: str = entities["noms"][0]
        consultant = self._find_consultant_by_name(nom_recherche)

        if not consultant:
            return {
                "response": f"‚ùå Je n'ai pas trouv√© de consultant nomm√© **{nom_recherche}** dans la base de donn√©es.",
                "data": None,
                "intent": "profil_professionnel",
                "confidence": 0.7,
            }

        try:
            with get_database_session() as session:
                consultant_db = (
                    session.query(Consultant)
                    .filter(Consultant.id == consultant.id)
                    .first()
                )

                if not consultant_db:
                    response = f"‚ùå Impossible de r√©cup√©rer les donn√©es de **{consultant.prenom} {consultant.nom}**."
                else:
                    # D√©terminer le type d'information demand√©e
                    if any(
                        word in question_lower
                        for word in ["grade", "niveau", "poste", "fonction"]
                    ):
                        response = self._get_profile_response_for_grade(
                            consultant, consultant_db
                        )
                    elif any(
                        word in question_lower
                        for word in ["contrat", "type contrat", "cdi", "cdd"]
                    ):
                        response = self._get_profile_response_for_contract(
                            consultant, consultant_db
                        )
                    elif any(
                        word in question_lower
                        for word in [
                            "soci√©t√©",
                            "societe",
                            "entreprise",
                            "quanteam",
                            "asigma",
                        ]
                    ):
                        response = self._get_profile_response_for_company(
                            consultant, consultant_db
                        )
                    else:
                        response = self._get_complete_profile_response(
                            consultant, consultant_db
                        )

        except (SQLAlchemyError, AttributeError, ValueError, TypeError) as e:
            response = f"‚ùå Erreur lors de la r√©cup√©ration du profil : {str(e)}"
            consultant_db = None

        return {
            "response": response,
            "data": {
                "consultant": {
                    "nom": consultant.nom,
                    "prenom": consultant.prenom,
                    "grade": (
                        getattr(consultant_db, "grade", None) if consultant_db else None
                    ),
                    "type_contrat": (
                        getattr(consultant_db, "type_contrat", None)
                        if consultant_db
                        else None
                    ),
                    "societe": (
                        getattr(consultant_db, "societe", None)
                        if consultant_db
                        else None
                    ),
                }
            },
            "intent": "profil_professionnel",
            "confidence": 0.9,
        }

    def _group_consultants_by_grade(self, consultants) -> Dict[str, List]:
        """Groupe les consultants par grade"""
        grades_count: Dict[str, List[Consultant]] = {}
        for consultant in consultants:
            grade = consultant.grade
            if grade not in grades_count:
                grades_count[grade] = []
            grades_count[grade].append(consultant)
        return grades_count

    def _handle_grade_statistics(self, session) -> str:
        """G√®re les statistiques par grade"""
        consultants = (
            session.query(Consultant)
            .filter(Consultant.grade.isnot(None))
            .all()
        )

        if consultants:
            grades_count = self._group_consultants_by_grade(consultants)

            response = "üéØ **R√©partition par grade :**\n\n"
            for grade, consultants_list in grades_count.items():
                response += f"‚Ä¢ **{grade}** : {len(consultants_list)} consultant(s)\n"
                if len(consultants_list) <= 5:  # Afficher les noms si pas trop nombreux
                    for c in consultants_list:
                        response += f"  - {c.prenom} {c.nom}\n"
        else:
            response = "‚ùì Aucun consultant n'a de grade renseign√©."
        
        return response

    def _count_consultants_by_contract_type(self, consultants, contract_type: str) -> int:
        """Compte les consultants d'un type de contrat sp√©cifique"""
        if contract_type.upper() == "CDI":
            return len([c for c in consultants if c.type_contrat and c.type_contrat.upper() == "CDI"])
        elif contract_type.upper() == "CDD":
            return len([c for c in consultants if c.type_contrat and c.type_contrat.upper() == "CDD"])
        elif contract_type.lower() == "stagiaire":
            return len([c for c in consultants if c.type_contrat and c.type_contrat.lower() == "stagiaire"])
        return 0

    def _handle_contract_count_query(self, consultants, question_lower: str) -> str:
        """G√®re les questions de comptage de consultants par contrat"""
        if "cdi" in question_lower:
            count = self._count_consultants_by_contract_type(consultants, "CDI")
            return f"üìã **{count} consultant(s) en CDI**"
        elif "cdd" in question_lower:
            count = self._count_consultants_by_contract_type(consultants, "CDD")
            return f"üìã **{count} consultant(s) en CDD**"
        elif "stagiaire" in question_lower:
            count = self._count_consultants_by_contract_type(consultants, "stagiaire")
            return f"üìã **{count} consultant(s) stagiaire(s)**"
        else:
            return self._get_all_contract_counts(consultants)

    def _get_all_contract_counts(self, consultants) -> str:
        """Retourne toutes les statistiques de contrats"""
        contrats_count: Dict[str, int] = {}
        for consultant in consultants:
            contrat = consultant.type_contrat
            if contrat not in contrats_count:
                contrats_count[contrat] = 0
            contrats_count[contrat] += 1

        response = "üìã **Nombre de consultants par type de contrat :**\n\n"
        for contrat, count in contrats_count.items():
            response += f"‚Ä¢ **{contrat}** : {count} consultant(s)\n"
        return response

    def _get_contract_detailed_breakdown(self, consultants) -> str:
        """Retourne la r√©partition d√©taill√©e par type de contrat"""
        contrats_list: Dict[str, List[Consultant]] = {}
        for consultant in consultants:
            contrat = consultant.type_contrat
            if contrat not in contrats_list:
                contrats_list[contrat] = []
            contrats_list[contrat].append(consultant)

        response = "üìã **R√©partition par type de contrat :**\n\n"
        for contrat, consultants_list in contrats_list.items():
            response += f"‚Ä¢ **{contrat}** : {len(consultants_list)} consultant(s)\n"
            if len(consultants_list) <= 5:  # Afficher les noms si pas trop nombreux
                for c in consultants_list:
                    response += f"  - {c.prenom} {c.nom}\n"
        return response

    def _handle_contract_statistics(self, session, question_lower: str) -> str:
        """G√®re les statistiques par type de contrat"""
        consultants = (
            session.query(Consultant)
            .filter(Consultant.type_contrat.isnot(None))
            .all()
        )

        # Si c'est une question "combien de consultants en CDI/CDD"
        if any(word in question_lower for word in ["combien"]):
            return self._handle_contract_count_query(consultants, question_lower)
        else:
            # R√©partition compl√®te par type de contrat
            if consultants:
                return self._get_contract_detailed_breakdown(consultants)
            else:
                return "‚ùì Aucun consultant n'a de type de contrat renseign√©."

    def _handle_company_statistics(self, session, question_lower: str) -> str:
        """G√®re les statistiques par soci√©t√©"""
        consultants = (
            session.query(Consultant)
            .filter(Consultant.societe.isnot(None))
            .all()
        )

        # Si c'est une recherche sp√©cifique pour une soci√©t√©
        if any(word in question_lower for word in ["quanteam", "asigma"]):
            societe_recherchee = (
                "Quanteam" if "quanteam" in question_lower else "Asigma"
            )
            consultants_societe = [
                c for c in consultants
                if c.societe and c.societe.lower() == societe_recherchee.lower()
            ]

            if consultants_societe:
                response = f"üè¢ **Consultants chez {societe_recherchee}** :\n\n"
                for i, consultant in enumerate(consultants_societe, 1):
                    status_icon = "üü¢" if consultant.disponibilite else "üî¥"
                    response += f"{i}. {status_icon} **{consultant.prenom} {consultant.nom}**"
                    if consultant.grade:
                        response += f" - {consultant.grade}"
                    if consultant.type_contrat:
                        response += f" ({consultant.type_contrat})"
                    response += "\n"

                response += (
                    self.TOTAL_PREFIX + str(len(consultants_societe)) + 
                    self.CONSULTANT_FOUND_SUFFIX
                )
            else:
                response = f"‚ùì Aucun consultant trouv√© chez {societe_recherchee}."
        else:
            # Statistiques g√©n√©rales par soci√©t√©
            if consultants:
                societes_count: Dict[str, List[Consultant]] = {}
                for consultant in consultants:
                    societe = consultant.societe
                    if societe not in societes_count:
                        societes_count[societe] = []
                    societes_count[societe].append(consultant)

                response = "üè¢ **R√©partition par soci√©t√© :**\n\n"
                for societe, consultants_list in societes_count.items():
                    response += f"‚Ä¢ **{societe}** : {len(consultants_list)} consultant(s)\n"
                    if len(consultants_list) <= 5:  # Afficher les noms si pas trop nombreux
                        for c in consultants_list:
                            response += f"  - {c.prenom} {c.nom}\n"
            else:
                response = "‚ùì Aucun consultant n'a de soci√©t√© renseign√©e."
        
        return response

    def _handle_professional_profile_question(self, entities: Dict) -> Dict[str, Any]:
        """G√®re les questions sur le profil professionnel (grade, type contrat, soci√©t√©)"""
        question_lower: str = self.last_question.lower()

        # Si un nom est mentionn√©, chercher ce consultant sp√©cifique
        if entities["noms"]:
            return self._handle_individual_profile_question(entities, question_lower)

        # Questions g√©n√©rales par crit√®re
        else:
            try:
                with get_database_session() as session:
                    if any(word in question_lower for word in [
                        "grade", "niveau", "junior", "confirm√©", "manager", "directeur"
                    ]):
                        response = self._handle_grade_statistics(session)
                    elif any(word in question_lower for word in [
                        "contrat", "cdi", "cdd", "stagiaire"
                    ]):
                        response = self._handle_contract_statistics(session, question_lower)
                    elif any(word in question_lower for word in [
                        "soci√©t√©", "societe", "quanteam", "asigma", "qui travaille", "qui est"
                    ]):
                        response = self._handle_company_statistics(session, question_lower)
                    else:
                        response = "ü§î Pr√©cisez quel aspect du profil professionnel vous int√©resse : grade, type de contrat, ou soci√©t√© ?"

            except (SQLAlchemyError, AttributeError, ValueError, TypeError, KeyError) as e:
                response = f"‚ùå Erreur lors de la r√©cup√©ration des donn√©es : {str(e)}"

            return {
                "response": response,
                "data": None,
                "intent": "profil_professionnel",
                "confidence": 0.8,
            }

    def _detect_skill_type(self, question_lower: str) -> Optional[str]:
        """D√©tecte le type de comp√©tence demand√© dans la question"""
        if any(word in question_lower for word in [
            "comp√©tences techniques", "technique", "technologie", "programmation"
        ]):
            return "technique"
        elif any(word in question_lower for word in [
            "comp√©tences fonctionnelles", "fonctionnelle", "m√©tier", "bancaire", "finance"
        ]):
            return "fonctionnelle"
        return None

    def _extract_skill_from_question(self, question_lower: str) -> Optional[str]:
        """Extrait le nom de la comp√©tence d'une question 'qui ma√Ætrise'"""
        patterns = [
            r"qui\s+ma√Ætrise\s+(.+?)(?:\?|$)",
            r"qui\s+sait\s+(.+?)(?:\?|$)",
            r"qui\s+conna√Æt\s+(.+?)(?:\?|$)",
            r"qui\s+connait\s+(.+?)(?:\?|$)",
            r"qui\s+a\s+(.+?)(?:\?|$)",
            r"qui\s+poss√®de\s+(.+?)(?:\?|$)",
        ]

        for pattern in patterns:
            match = re.search(pattern, question_lower)
            if match:
                competence_found = match.group(1).strip()
                # Nettoyer les articles et pr√©positions
                competence_found = re.sub(
                    r"^(le|la|les|du|de|des|en|une?)\s+", "", competence_found
                )
                competence_found = re.sub(
                    r"\s+(comp√©tence|skill)s?$", "", competence_found
                )
                return competence_found
        return None

    def _handle_specific_skill_search(self, competence: str, type_competence: Optional[str]) -> Dict[str, Any]:
        """G√®re la recherche de consultants ayant une comp√©tence sp√©cifique"""
        consultants = self._find_consultants_by_skill(competence, type_competence)

        if consultants:
            noms = [f"**{c.prenom} {c.nom}**" for c in consultants]
            response = f"üéØ Consultants ma√Ætrisant **{competence.title()}** :\n\n"
            response += "\n".join([f"‚Ä¢ {nom}" for nom in noms])
            response += (
                self.STATS_PREFIX + str(len(consultants)) + self.CONSULTANT_FOUND_SUFFIX
            )
        else:
            response = f"‚ùå Aucun consultant ne ma√Ætrise **{competence}** dans notre base."

        return {
            "response": response,
            "data": {
                "consultants": [
                    {"nom": c.nom, "prenom": c.prenom} for c in consultants
                ]
            },
            "intent": "competences",
            "confidence": 0.9,
        }

    def _handle_consultant_skills_inquiry(self, nom: str, type_competence: Optional[str]) -> Dict[str, Any]:
        """G√®re les questions sur les comp√©tences d'un consultant sp√©cifique"""
        consultant = self._find_consultant_by_name(nom)

        if consultant:
            skills = self._get_consultant_skills(consultant.id, type_competence)

            if skills:
                response = f"üéØ **Comp√©tences de {consultant.prenom} {consultant.nom} :**\n\n"

                # Grouper par cat√©gorie
                categories: Dict[str, List[Dict[str, Any]]] = {}
                for skill in skills:
                    categorie = skill["categorie"] or "Autre"
                    if categorie not in categories:
                        categories[categorie] = []
                    categories[categorie].append(skill)

                # Afficher par cat√©gorie
                for categorie, competences in categories.items():
                    response += f"**üîπ {categorie.title()} :**\n"
                    for comp in competences:
                        niveau_emoji = {
                            "debutant": "üü°",
                            "intermediaire": "üü†",
                            "expert": "üî¥",
                        }.get(comp["niveau_maitrise"], "‚ö™")

                        experience_text = ""
                        if comp["annees_experience"] and comp["annees_experience"] > 0:
                            if comp["annees_experience"] == 1:
                                experience_text = f" ({comp['annees_experience']} an)"
                            else:
                                experience_text = f" ({comp['annees_experience']:.0f} ans)"

                        response += f"  {niveau_emoji} **{comp['nom']}** - {comp['niveau_maitrise'].title()}{experience_text}\n"
                    response += "\n"

                response += f"üìä **Total : {len(skills)} comp√©tence(s)**"
            else:
                response = f"‚ùå Aucune comp√©tence enregistr√©e pour **{consultant.prenom} {consultant.nom}**."
        else:
            response = f"‚ùå Consultant **{nom}** introuvable."

        return {
            "response": response,
            "data": {
                "consultant": consultant.nom if consultant else None,
                "skills_count": len(skills) if consultant else 0,
            },
            "intent": "competences",
            "confidence": 0.9,
        }

    def _handle_skills_question(self, entities: Dict) -> Dict[str, Any]:
        """G√®re les questions sur les comp√©tences"""

        # D√©tecter le type de comp√©tences demand√©
        question_lower: str = self.last_question.lower()
        type_competence = self._detect_skill_type(question_lower)

        # Si une comp√©tence sp√©cifique est mentionn√©e
        if entities["competences"]:
            return self._handle_specific_skill_search(entities["competences"][0], type_competence)

        # Recherche dynamique de comp√©tence dans la question
        elif any(word in question_lower for word in [
            "qui ma√Ætrise", "qui sait", "qui conna√Æt", "qui connait"
        ]):
            competence_found = self._extract_skill_from_question(question_lower)

            if competence_found:
                return self._handle_specific_skill_search(competence_found, type_competence)

        # Question g√©n√©rale sur les comp√©tences d'un consultant
        elif entities["noms"]:
            return self._handle_consultant_skills_inquiry(entities["noms"][0], type_competence)

        return {
            "response": "ü§î Pouvez-vous pr√©ciser quelle comp√©tence ou quel consultant vous int√©resse ?",
            "data": None,
            "intent": "competences",
            "confidence": 0.5,
        }

    def _extract_consultant_name_from_language_question(self, question_lower: str) -> Optional[str]:
        """Extrait le nom du consultant d'une question sur les langues"""
        patterns = [
            r"quelles?\s+langues?\s+parle\s+(\w+)",
            r"langues?\s+parle\s+(\w+)",
            r"langues?\s+de\s+(\w+)",
            r"(\w+)\s+parle\s+quelles?\s+langues?",
            r"quelles?\s+sont\s+les\s+langues?\s+de\s+(\w+)",
        ]

        for pattern in patterns:
            match = re.search(pattern, question_lower)
            if match:
                return match.group(1)
        return None

    def _extract_language_from_question(self, question_lower: str) -> Optional[str]:
        """Extrait le nom de la langue d'une question 'qui parle'"""
        patterns = [
            r"qui\s+parle\s+(.+?)(?:\?|$)",
            r"parlent\s+(.+?)(?:\?|$)",
            r"qui.+parle.+(.+?)(?:\?|$)",
        ]

        for pattern in patterns:
            match = re.search(pattern, question_lower)
            if match:
                langue_found = match.group(1).strip()
                # Nettoyer les articles
                langue_found = re.sub(
                    r"^(le|la|les|du|de|des|en|une?)\s+", "", langue_found
                )
                return langue_found
        return None

    def _format_consultant_languages_response(self, consultant) -> str:
        """Formate la r√©ponse pour les langues d'un consultant"""
        if not consultant.langues:
            return f"‚ùå Aucune langue enregistr√©e pour **{consultant.prenom} {consultant.nom}**."

        response = (
            "üåç **Langues parl√©es par "
            + consultant.prenom + " " + consultant.nom + " :**\n\n"
        )

        flag_emoji = {
            "FR": "üá´üá∑", "EN": "üá¨üáß", "ES": "üá™üá∏", "DE": "üá©üá™", "IT": "üáÆüáπ",
            "PT": "üáµüáπ", "NL": "üá≥üá±", "RU": "üá∑üá∫", "ZH": "üá®üá≥", "JA": "üáØüáµ",
            "AR": "üá∏üá¶", "HI": "üáÆÔøΩ",
        }

        for cl in consultant.langues:
            emoji = flag_emoji.get(cl.langue.code_iso, "üåç")
            response += f"  {emoji} **{cl.langue.nom}** - {cl.niveau_label}"
            if cl.commentaire:
                response += f" - {cl.commentaire}"
            response += "\n"

        response += f"\nüìä **Total : {len(consultant.langues)} langue(s)**"
        return response

    def _handle_specific_language_search(self, langue_recherchee: str) -> Dict[str, Any]:
        """G√®re la recherche de consultants parlant une langue sp√©cifique"""
        consultants = self._find_consultants_by_language(langue_recherchee)

        if consultants:
            noms = [f"**{c.prenom} {c.nom}**" for c in consultants]
            response = f"üåç Consultants parlant **{langue_recherchee.title()}** :\n\n"
            response += "\n".join([f"‚Ä¢ {nom}" for nom in noms])
            response += f"\n\nüìä **{len(consultants)} consultant(s) trouv√©(s)**"

            # D√©tails des niveaux si moins de 5 consultants
            if len(consultants) <= 5:
                response += "\n\nüéØ **Niveaux d√©taill√©s :**"
                for consultant in consultants:
                    for cl in consultant.langues:
                        if cl.langue.nom.lower() == langue_recherchee.lower():
                            response += f"\n  ‚Ä¢ **{consultant.prenom} {consultant.nom}** : {cl.niveau_label}"
                            if cl.commentaire:
                                response += f" - {cl.commentaire}"
                            break

            return {
                "response": response,
                "data": {
                    "consultants": [
                        {"nom": c.nom, "prenom": c.prenom} for c in consultants
                    ]
                },
                "intent": "langues",
                "confidence": 0.9,
            }
        else:
            return {
                "response": f"‚ùå Aucun consultant ne parle **{langue_recherchee}** dans notre base.",
                "data": {"consultants": []},
                "intent": "langues",
                "confidence": 0.8,
            }

    def _handle_consultant_languages_inquiry(self, entities: Dict) -> Dict[str, Any]:
        """G√®re les questions sur les langues d'un consultant sp√©cifique"""
        question_lower = self.last_question.lower()
        
        # Si pas de nom d√©tect√© dans entities, essayer d'extraire manuellement
        nom = entities["noms"][0] if entities["noms"] else self._extract_consultant_name_from_language_question(question_lower)

        if nom:
            consultant = self._find_consultant_by_name(nom)

            if consultant:
                response = self._format_consultant_languages_response(consultant)
                return {
                    "response": response,
                    "data": {
                        "consultant": consultant.nom,
                        "languages_count": len(consultant.langues) if consultant.langues else 0,
                    },
                    "intent": "langues",
                    "confidence": 0.8,
                }
            else:
                return {
                    "response": f"‚ùå Consultant **{nom}** introuvable.",
                    "data": {"consultant": None, "languages_count": 0},
                    "intent": "langues",
                    "confidence": 0.8,
                }
        else:
            # Question g√©n√©rale sur les langues sans nom sp√©cifique
            return {
                "response": 'üåç Pour conna√Ætre les langues d\'un consultant, demandez : "Quelles langues parle [nom] ?"\n\nOu pour trouver qui parle une langue : "Qui parle anglais ?"',
                "data": {},
                "intent": "langues",
                "confidence": 0.6,
            }

    def _handle_languages_question(self, entities: Dict) -> Dict[str, Any]:
        """G√®re les questions sur les langues parl√©es par les consultants"""

        # Si une langue sp√©cifique est mentionn√©e
        if entities["langues"]:
            return self._handle_specific_language_search(entities["langues"][0])

        # Question g√©n√©rale sur les langues d'un consultant
        elif entities["noms"] or any(
            word in self.last_question.lower()
            for word in ["quelles langues", "langues de", "langues parl√©es"]
        ):
            return self._handle_consultant_languages_inquiry(entities)

        # Recherche dynamique de langue dans la question
        elif any(
            word in self.last_question.lower()
            for word in ["qui parle", "parle", "parlent", "bilingue"]
        ):
            question_lower = self.last_question.lower()
            langue_found = self._extract_language_from_question(question_lower)

            if langue_found:
                return self._handle_specific_language_search(langue_found)

        # Question g√©n√©rale sur les langues
        return {
            "response": 'üåç Pour conna√Ætre les langues d\'un consultant, demandez : "Quelles langues parle [nom] ?"\n\nOu pour trouver qui parle une langue : "Qui parle anglais ?"',
            "data": {},
            "intent": "langues",
            "confidence": 0.6,
        }

    def _handle_missions_question(self, entities: Dict) -> Dict[str, Any]:
        """G√®re les questions sur les missions"""

        # D√©tecter si c'est une question sur le nombre de missions
        question_lower: str = self.last_question.lower()
        is_count_question = any(
            word in question_lower for word in ["combien", "nombre"]
        )

        if entities["entreprises"]:
            entreprise: str = entities["entreprises"][0]
            missions = self._get_missions_by_company(entreprise)

            if is_count_question:
                response = (
                    "üìä **"
                    + str(len(missions))
                    + " mission(s)** trouv√©e(s) chez **"
                    + entreprise.title()
                    + "**"
                )
            elif missions:
                response = f"üè¢ **Missions chez {entreprise.title()} :**\n\n"
                for mission in missions[:5]:  # Limiter √† 5 r√©sultats
                    consultant_nom = (
                        f"{mission.consultant.prenom} {mission.consultant.nom}"
                    )
                    response += f"‚Ä¢ **{consultant_nom}** - {mission.nom_mission} ({mission.date_debut.strftime('%Y')})\n"

                if len(missions) > 5:
                    response += f"\n... et {len(missions) - 5} autres missions"

                response += "\n\nüìä **Total : " + str(len(missions)) + " mission(s)**"
            else:
                response = f"‚ùå Aucune mission trouv√©e chez **{entreprise}**."

            return {
                "response": response,
                "data": {"missions": len(missions), "entreprise": entreprise},
                "intent": "missions",
                "confidence": 0.9,
            }

        elif entities["noms"]:
            nom: str = entities["noms"][0]
            consultant = self._find_consultant_by_name(nom)

            if consultant:
                missions = self._get_missions_by_consultant(consultant.id)

                if is_count_question:
                    # Question sp√©cifique sur le nombre
                    response = (
                        "üìä **"
                        + consultant.prenom
                        + " "
                        + consultant.nom
                        + "** a **"
                        + str(len(missions))
                        + " mission(s)** dans la base"
                    )
                    if missions:
                        missions_en_cours = [
                            m for m in missions if m.statut == "en_cours"
                        ]
                        if missions_en_cours:
                            response += (
                                " (dont " + str(len(missions_en_cours)) + " en cours)"
                            )
                elif missions:
                    response = (
                        f"üíº **Missions de {consultant.prenom} {consultant.nom} :**\n\n"
                    )
                    for mission in missions:
                        status_icon = "üü¢" if mission.statut == "en_cours" else "‚úÖ"
                        response += f"{status_icon} **{mission.client}** - {mission.nom_mission}\n"
                        response += f"   üìÖ {mission.date_debut.strftime('%m/%Y')} ‚Üí "
                        if mission.date_fin:
                            response += f"{mission.date_fin.strftime('%m/%Y')}"
                        else:
                            response += "En cours"
                        if mission.taux_journalier:
                            response += (
                                " | üí∞ " + str(mission.taux_journalier) + "‚Ç¨/jour"
                            )
                        response += "\n\n"

                    response += "üìä **Total : " + str(len(missions)) + " mission(s)**"
                else:
                    response = f"‚ùå Aucune mission trouv√©e pour **{consultant.prenom} {consultant.nom}**."
            else:
                response = f"‚ùå Consultant **{nom}** introuvable."

            return {
                "response": response,
                "data": {
                    "consultant": nom,
                    "missions_count": len(missions) if consultant else 0,
                },
                "intent": "missions",
                "confidence": 0.9,
            }

        return {
            "response": "ü§î Voulez-vous conna√Ætre les missions d'un consultant ou d'une entreprise sp√©cifique ?",
            "data": None,
            "intent": "missions",
            "confidence": 0.5,
        }

    def _handle_stats_question(self) -> Dict[str, Any]:
        """G√®re les questions statistiques"""

        stats = self._get_general_stats()

        # Si c'est une question sp√©cifique sur le nombre de consultants
        if any(pattern in self.last_question for pattern in ["combien", "nombre"]):
            if (
                "consultant" in self.last_question
                and "mission" not in self.last_question
            ):
                response = f"üë• **Vous avez {stats['consultants_total']} consultants** dans votre base de donn√©es.\n\n"
                response += (
                    "üìä D√©tail : "
                    + str(stats["consultants_actifs"])
                    + " disponibles, "
                    + str(stats["consultants_inactifs"])
                    + " indisponibles"
                )

                return {
                    "response": response,
                    "data": {"consultants_count": stats["consultants_total"]},
                    "intent": "statistiques",
                    "confidence": 0.95,
                }

        # Statistiques compl√®tes par d√©faut
        response = f"""üìä **Statistiques g√©n√©rales :**

üë• **Consultants :**
‚Ä¢ Total : **{stats['consultants_total']}**
‚Ä¢ Actifs : **{stats['consultants_actifs']}**
‚Ä¢ Inactifs : **{stats['consultants_inactifs']}**

üè¢ **Practices :**
‚Ä¢ Total : **{stats['practices_total']}**

üíº **Missions :**
‚Ä¢ Total : **{stats['missions_total']}**
‚Ä¢ En cours : **{stats['missions_en_cours']}**
‚Ä¢ Termin√©es : **{stats['missions_terminees']}**

ÔøΩ **Documents :**
‚Ä¢ Total CVs : **{stats['cvs_total']}**
‚Ä¢ Consultants avec CV : **{stats['consultants_avec_cv']}**

ÔøΩüí∞ **Financier :**
‚Ä¢ TJM moyen : **{stats['tjm_moyen']:,.0f} ‚Ç¨**
‚Ä¢ Salaire moyen : **{stats['salaire_moyen']:,.0f} ‚Ç¨**
‚Ä¢ CJM moyen : **{stats['cjm_moyen']:,.0f} ‚Ç¨**"""

        return {
            "response": response,
            "data": {"stats": stats},
            "intent": "statistiques",
            "confidence": 0.9,
        }

    def _handle_contact_question(self, entities: Dict) -> Dict[str, Any]:
        """G√®re les questions sur les contacts (email, t√©l√©phone)"""

        if entities["noms"]:
            nom: str = entities["noms"][0]
            consultant = self._find_consultant_by_name(nom)

            if consultant:
                # D√©terminer le type d'information demand√©e
                question_lower: str = self.last_question.lower()

                if any(word in question_lower for word in ["mail", "email", "e-mail"]):
                    if consultant.email:
                        response = f"üìß L'email de **{consultant.prenom} {consultant.nom}** est : **{consultant.email}**"
                    else:
                        response = f"‚ùì D√©sol√©, l'email de **{consultant.prenom} {consultant.nom}** n'est pas renseign√© dans la base."

                elif any(
                    word in question_lower for word in ["t√©l√©phone", "tel", "num√©ro"]
                ):
                    if consultant.telephone:
                        response = f"üìû Le t√©l√©phone de **{consultant.prenom} {consultant.nom}** est : **{consultant.telephone}**"
                    else:
                        response = f"‚ùì D√©sol√©, le t√©l√©phone de **{consultant.prenom} {consultant.nom}** n'est pas renseign√© dans la base."

                else:
                    # Information de contact compl√®te
                    response = (
                        f"üìû **Contact de {consultant.prenom} {consultant.nom} :**\n\n"
                    )
                    response += (
                        f"üìß Email : **{consultant.email or 'Non renseign√©'}**\n"
                    )
                    response += (
                        f"üìû T√©l√©phone : **{consultant.telephone or 'Non renseign√©'}**"
                    )

                return {
                    "response": response,
                    "data": {
                        "consultant": consultant.nom,
                        "email": consultant.email,
                        "telephone": consultant.telephone,
                    },
                    "intent": "contact",
                    "confidence": 0.9,
                }
            else:
                return {
                    "response": f"‚ùå Je n'ai pas trouv√© de consultant nomm√© **{nom}** dans la base de donn√©es.",
                    "data": None,
                    "intent": "contact",
                    "confidence": 0.7,
                }

        return {
            "response": "ü§î De quel consultant souhaitez-vous conna√Ætre les coordonn√©es ?",
            "data": None,
            "intent": "contact",
            "confidence": 0.5,
        }

    def _handle_list_consultants_question(self) -> Dict[str, Any]:
        """G√®re les questions pour lister les consultants selon des crit√®res"""

        question_lower: str = self.last_question.lower()

        # D√©terminer le filtre √† appliquer
        if "disponibles" in question_lower or "disponible" in question_lower:
            with get_database_session() as session:
                consultants = (
                    session.query(Consultant).filter(Consultant.disponibilite).all()
                )
            titre = "üë• **Consultants disponibles :**"
        elif "indisponibles" in question_lower or "indisponible" in question_lower:
            with get_database_session() as session:
                consultants = (
                    session.query(Consultant)
                    .filter(Consultant.disponibilite is False)
                    .all()
                )
            titre = "üë• **Consultants indisponibles :**"
        elif "actifs" in question_lower or "actif" in question_lower:
            with get_database_session() as session:
                consultants = (
                    session.query(Consultant).filter(Consultant.disponibilite).all()
                )
            _ = "üë• **Consultants actifs :**"
        else:
            # Tous les consultants
            with get_database_session() as session:

                consultants = session.query(Consultant).all()
            titre = "üë• **Tous les consultants :**"

        if not consultants:
            return {
                "response": "‚ùì Aucun consultant ne correspond √† ce crit√®re.",
                "data": None,
                "intent": "liste_consultants",
                "confidence": 0.8,
            }

        # Construire la r√©ponse
        response = f"{titre}\n\n"

        for i, consultant in enumerate(consultants, 1):
            status_icon = "üü¢" if consultant.disponibilite else "üî¥"
            response += f"{i}. {status_icon} **{consultant.prenom} {consultant.nom}**"

            if consultant.email:
                response += f" - {consultant.email}"

            if consultant.salaire_actuel:
                cjm = consultant.salaire_actuel * 1.8 / 216
                response += (
                    f" - {consultant.salaire_actuel:,.0f} ‚Ç¨/an - CJM: {cjm:,.0f} ‚Ç¨"
                )

            response += "\n"

        response += "\nüìä **Total : " + str(len(consultants)) + " consultant(s)**"

        return {
            "response": response,
            "data": {
                "consultants": [
                    {
                        "nom": c.nom,
                        "prenom": c.prenom,
                        "email": c.email,
                        "disponibilite": c.disponibilite,
                        "salaire": c.salaire_actuel,
                        "cjm": (
                            (c.salaire_actuel * 1.8 / 216) if c.salaire_actuel else None
                        ),
                    }
                    for c in consultants
                ],
                "count": len(consultants),
            },
            "intent": "liste_consultants",
            "confidence": 0.9,
        }

    def _handle_consultant_search(self, entities: Dict) -> Dict[str, Any]:
        """G√®re la recherche d'informations sur un consultant"""

        if entities["noms"]:
            nom: str = entities["noms"][0]
            consultant = self._find_consultant_by_name(nom)

            if consultant:
                response = f"""üë§ **{consultant.prenom} {consultant.nom}**

üìß Email : {consultant.email or 'Non renseign√©'}
üìû T√©l√©phone : {consultant.telephone or 'Non renseign√©'}
üìä Disponibilit√© : **{'Disponible' if consultant.disponibilite else 'Indisponible'}**
üìÖ Date cr√©ation : {consultant.date_creation.strftime(self.DATE_FORMAT) if consultant.date_creation else 'Non renseign√©e'}"""

                if consultant.salaire_actuel:
                    cjm = consultant.salaire_actuel * 1.8 / 216
                    response += (
                        "\nüí∞ Salaire : **"
                        + f"{consultant.salaire_actuel:,.0f}"
                        + " ‚Ç¨**"
                    )
                    response += "\nüìà CJM : **" + f"{cjm:,.0f}" + " ‚Ç¨**"

                # Ajouter info sur les missions
                missions_count = len(consultant.missions)
                if missions_count > 0:
                    response += f"\nüíº Missions : **{missions_count}** mission(s)"
            else:
                response = (
                    f"‚ùå Consultant **{nom}** introuvable dans la base de donn√©es."
                )

            return {
                "response": response,
                "data": {"consultant": consultant.nom if consultant else None},
                "intent": "recherche_consultant",
                "confidence": 0.9,
            }

        return {
            "response": "ü§î De quel consultant souhaitez-vous conna√Ætre les informations ?",
            "data": None,
            "intent": "recherche_consultant",
            "confidence": 0.5,
        }

    def _handle_general_question(self) -> Dict[str, Any]:
        """G√®re les questions g√©n√©rales"""

        responses = [
            "ü§ñ Je suis l√† pour vous aider √† interroger la base de donn√©es des consultants !",
            "",
            "üí° **Voici quelques exemples de questions :**",
            "",
            'üí∞ *Salaires :* "Quel est le salaire de Jean Dupont ?"',
            'ÔøΩ *Exp√©rience :* "Quelle est l\'exp√©rience de Jean Dupont ?"',
            'üéØ *Grade :* "Quel est le grade de Marie ?"',
            'üìã *Contrat :* "Quel est le type de contrat de Paul ?"',
            'üè¢ *Soci√©t√© :* "Dans quelle soci√©t√© travaille Anne ?"',
            'ÔøΩüìß *Contact :* "Quel est l\'email de Marie ?"',
            'üë• *Listes :* "Quels sont les consultants disponibles ?"',
            'üîç *Comp√©tences :* "Qui ma√Ætrise Python ?"',
            'üíº *Missions :* "Quelles sont les missions chez BNP Paribas ?"',
            'ÔøΩ *Statistiques :* "Combien de consultants sont actifs ?"',
            'üë§ *Profils :* "Qui est Marie Martin ?"',
            "",
            "Que souhaitez-vous savoir ? üòä",
        ]

        return {
            "response": "\n".join(responses),
            "data": None,
            "intent": "general",
            "confidence": 1.0,
        }

    def _handle_practices_question(self, entities: Dict) -> Dict[str, Any]:
        """
        G√®re les questions sur les practices (√©quipes) des consultants.

        Args:
            entities: Dictionnaire contenant les entit√©s extraites de la question
                     (noms, entreprises, comp√©tences, langues, etc.)

        Returns:
            Dictionnaire contenant :
            - response: R√©ponse format√©e pour l'utilisateur
            - data: Donn√©es structur√©es sur les practices
            - intent: Type d'intention d√©tect√© ("practices")
            - confidence: Niveau de confiance de la r√©ponse (0.0 √† 1.0)

        Raises:
            SQLAlchemyError: En cas d'erreur de base de donn√©es
            AttributeError: Si les donn√©es de practice sont malform√©es

        Example:
            >>> entities = {"practices": ["Data"]}
            >>> result = chatbot._handle_practices_question(entities)
            >>> print(result["response"])
            üë• **Practice Data** :
            üìã **5 consultant(s)** :
            1. üü¢ **Jean Dupont** - CJM: 450 ‚Ç¨
            ...
        """
        from database.models import Practice

        # Si une practice sp√©cifique est mentionn√©e
        if entities["practices"]:
            practice_name: str = entities["practices"][0]
            with get_database_session() as session:
                practice = (
                    session.query(Practice)
                    .filter(func.lower(Practice.nom) == practice_name.lower())
                    .first()
                )

            if practice:
                # R√©cup√©rer les consultants de cette practice
                consultants = list(practice.consultants)

                if consultants:
                    response = f"üë• **Practice {practice.nom}** :\n\n"
                    response += f"üìã **{len(consultants)} consultant(s)** :\n"

                    for i, consultant in enumerate(consultants, 1):
                        status_icon = "üü¢" if consultant.disponibilite else "üî¥"
                        cjm = (
                            (consultant.salaire_actuel * 1.8 / 216)
                            if consultant.salaire_actuel
                            else 0
                        )
                        response += f"{i}. {status_icon} **{consultant.prenom} {consultant.nom}**"
                        if consultant.salaire_actuel:
                            response += f" - CJM: {cjm:,.0f} ‚Ç¨"
                        response += "\n"

                    if practice.responsable:
                        response += f"\nüë®‚Äçüíº **Responsable** : {practice.responsable}"
                else:
                    response = (
                        f"üìã **Practice {practice.nom}** : Aucun consultant assign√©"
                    )

                return {
                    "response": response,
                    "data": {
                        "practice": practice.nom,
                        "consultants": [
                            {
                                "nom": c.nom,
                                "prenom": c.prenom,
                                "disponibilite": c.disponibilite,
                                "cjm": (
                                    (c.salaire_actuel * 1.8 / 216)
                                    if c.salaire_actuel
                                    else None
                                ),
                            }
                            for c in consultants
                        ],
                    },
                    "intent": "practices",
                    "confidence": 0.9,
                }
            else:
                return {
                    "response": f"‚ùå Practice **{practice_name}** introuvable dans la base.",
                    "data": None,
                    "intent": "practices",
                    "confidence": 0.7,
                }

        # Question g√©n√©rale sur les practices
        else:
            with get_database_session() as session:

                practices = session.query(Practice).filter(Practice.actif).all()

            if practices:
                response = "üè¢ **Practices disponibles** :\n\n"

                for practice in practices:
                    nb_consultants = len(list(practice.consultants))
                    nb_disponibles = len(
                        [c for c in practice.consultants if c.disponibilite]
                    )

                    response += f"‚Ä¢ **{practice.nom}** : {nb_consultants} consultant(s) ({nb_disponibles} disponible(s))\n"
                    if practice.responsable:
                        response += f"  üë®‚Äçüíº Responsable : {practice.responsable}\n"

                return {
                    "response": response,
                    "data": {
                        "practices": [
                            {
                                "nom": p.nom,
                                "consultants_total": len(list(p.consultants)),
                                "consultants_disponibles": len(
                                    [c for c in p.consultants if c.disponibilite]
                                ),
                                "responsable": p.responsable,
                            }
                            for p in practices
                        ]
                    },
                    "intent": "practices",
                    "confidence": 0.8,
                }
            else:
                return {
                    "response": "‚ùì Aucune practice active trouv√©e dans la base.",
                    "data": None,
                    "intent": "practices",
                    "confidence": 0.6,
                }

    def _handle_cvs_question(self, entities: Dict) -> Dict[str, Any]:
        """
        G√®re les questions sur les CVs des consultants.

        Args:
            entities: Dictionnaire contenant les entit√©s extraites de la question
                     (noms, entreprises, comp√©tences, langues, etc.)

        Returns:
            Dictionnaire contenant :
            - response: R√©ponse format√©e sur les CVs
            - data: Donn√©es structur√©es sur les CVs
            - intent: Type d'intention d√©tect√© ("cvs")
            - confidence: Niveau de confiance de la r√©ponse (0.0 √† 1.0)

        Raises:
            SQLAlchemyError: En cas d'erreur de base de donn√©es
            AttributeError: Si les donn√©es de CV sont malform√©es

        Example:
            >>> entities = {"noms": ["Jean Dupont"]}
            >>> result = chatbot._handle_cvs_question(entities)
            >>> print(result["response"])
            üìÅ **CVs de Jean Dupont** :
            1. **CV_Jean_Dupont.pdf**
               üìÖ Upload√© le : 15/01/2024
               üìè Taille : 2.5 MB
               ‚úÖ Contenu analys√©
            üìä **Total : 1 document(s)**
        """
        from database.models import CV

        # Si un consultant sp√©cifique est mentionn√©
        if entities["noms"]:
            nom_recherche: str = entities["noms"][0]
            consultant = self._find_consultant_by_name(nom_recherche)

            if consultant:
                cvs = consultant.cvs

                if cvs:
                    response = (
                        "üìÅ **CVs de "
                        + consultant.prenom
                        + " "
                        + consultant.nom
                        + self.SECTION_HEADER_SUFFIX
                    )

                    for i, cv in enumerate(cvs, 1):
                        taille_mb = (
                            (cv.taille_fichier / 1024 / 1024)
                            if cv.taille_fichier
                            else 0
                        )
                        date_upload = (
                            cv.date_upload.strftime(self.DATE_FORMAT)
                            if cv.date_upload
                            else "N/A"
                        )

                        response += str(i) + ". **" + cv.fichier_nom + "**\n"
                        response += "   üìÖ Upload√© le : " + date_upload + "\n"
                        response += "   üìè Taille : " + str(taille_mb) + " MB\n"
                        if cv.contenu_extrait:
                            response += "   ‚úÖ Contenu analys√©\n"
                        response += "\n"

                    response += "üìä **Total : " + str(len(cvs)) + " document(s)**"
                else:
                    response = (
                        "üìÅ **"
                        + consultant.prenom
                        + " "
                        + consultant.nom
                        + "** : Aucun CV upload√©"
                    )

                return {
                    "response": response,
                    "data": {
                        "consultant": f"{consultant.prenom} {consultant.nom}",
                        "cvs": [
                            {
                                "nom": cv.fichier_nom,
                                "date_upload": (
                                    cv.date_upload.isoformat()
                                    if cv.date_upload
                                    else None
                                ),
                                "taille": cv.taille_fichier,
                                "contenu_analyse": bool(cv.contenu_extrait),
                            }
                            for cv in cvs
                        ],
                    },
                    "intent": "cvs",
                    "confidence": 0.9,
                }
            else:
                return {
                    "response": f"‚ùå Consultant **{nom_recherche}** introuvable.",
                    "data": None,
                    "intent": "cvs",
                    "confidence": 0.7,
                }

        # Question g√©n√©rale sur les CVs
        else:
            with get_database_session() as session:

                cvs_total = session.query(CV).count()
            with get_database_session() as session:

                consultants_avec_cv = (
                    session.query(Consultant).join(CV).distinct().count()
                )

            response = "üìÅ **Statistiques des CVs** :\n\n"
            response += "‚Ä¢ Total de documents : **" + str(cvs_total) + "**\n"
            response += "‚Ä¢ Consultants avec CV : **" + str(consultants_avec_cv) + "**\n"

            # Top 3 consultants avec le plus de CVs
            from sqlalchemy import func

            with get_database_session() as session:

                top_consultants = session.query(
                    Consultant,
                    func.count(CV.id)
                    .label("nb_cvs")
                    .join(CV)
                    .group_by(Consultant.id)
                    .order_by(func.count(CV.id).desc())
                    .limit(3)
                    .all(),
                )

            if top_consultants:
                response += "\nüèÜ **Top consultants (nombre de CVs)** :\n"
                for consultant, nb_cvs in top_consultants:
                    response += (
                        "‚Ä¢ **"
                        + consultant.prenom
                        + " "
                        + consultant.nom
                        + "** : "
                        + str(nb_cvs)
                        + " CV(s)\n"
                    )

            return {
                "response": response,
                "data": {
                    "cvs_total": cvs_total,
                    "consultants_avec_cv": consultants_avec_cv,
                    "top_consultants": [
                        {"nom": c.nom, "prenom": c.prenom, "nb_cvs": nb}
                        for c, nb in top_consultants
                    ],
                },
                "intent": "cvs",
                "confidence": 0.8,
            }

    # M√©thodes utilitaires pour les requ√™tes DB

    def _find_consultant_by_name(self, nom_recherche: str) -> Optional[Consultant]:
        """
        Recherche flexible d'un consultant par son nom.

        Effectue d'abord une recherche exacte sur pr√©nom, nom ou nom complet,
        puis une recherche partielle si aucune correspondance exacte n'est trouv√©e.

        Args:
            nom_recherche: Nom ou pr√©nom du consultant √† rechercher (insensible √† la casse)

        Returns:
            Objet Consultant si trouv√©, None sinon

        Raises:
            SQLAlchemyError: En cas d'erreur de base de donn√©es

        Example:
            >>> consultant = chatbot._find_consultant_by_name("Jean Dupont")
            >>> print(consultant.prenom, consultant.nom)
            Jean Dupont

            >>> consultant = chatbot._find_consultant_by_name("Dupont")
            >>> print(consultant.prenom, consultant.nom)
            Jean Dupont
        """

        # Essayer une correspondance exacte d'abord
        with get_database_session() as session:

            consultant = (
                session.query(Consultant)
                .filter(
                    or_(
                        func.lower(Consultant.nom) == nom_recherche.lower(),
                        func.lower(Consultant.prenom) == nom_recherche.lower(),
                        func.lower(func.concat(Consultant.prenom, " ", Consultant.nom))
                        == nom_recherche.lower(),
                        func.lower(func.concat(Consultant.nom, " ", Consultant.prenom))
                        == nom_recherche.lower(),
                    )
                )
                .first()
            )

        if consultant:
            return consultant

        # Essayer une correspondance partielle
        with get_database_session() as session:

            consultant = (
                session.query(Consultant)
                .filter(
                    or_(
                        func.lower(Consultant.nom).like(f"%{nom_recherche.lower()}%"),
                        func.lower(Consultant.prenom).like(
                            f"%{nom_recherche.lower()}%"
                        ),
                    )
                )
                .first()
            )

        return consultant

    def _find_consultants_by_skill(
        self, competence: str, type_competence: Optional[str] = None
    ) -> List[Any]:
        """
        Recherche les consultants ma√Ætrisant une comp√©tence sp√©cifique.

        Args:
            competence: Nom de la comp√©tence √† rechercher (insensible √† la casse)
            type_competence: Type de comp√©tence (technique/fonctionnelle) pour filtrer (optionnel)

        Returns:
            Liste des objets Consultant ma√Ætrisant la comp√©tence

        Raises:
            SQLAlchemyError: En cas d'erreur de base de donn√©es

        Example:
            >>> consultants = chatbot._find_consultants_by_skill("Python", "technique")
            >>> print(f"Trouv√© {len(consultants)} consultants Python")

            >>> consultants = chatbot._find_consultants_by_skill("SQL")
            >>> print(f"Trouv√© {len(consultants)} consultants SQL")
        """
        from database.models import Competence
        from database.models import ConsultantCompetence

        # Construction de la requ√™te de base
        with get_database_session() as session:

            query = (
                session.query(Consultant)
                .join(
                    ConsultantCompetence,
                    Consultant.id == ConsultantCompetence.consultant_id,
                )
                .join(Competence, ConsultantCompetence.competence_id == Competence.id)
                .filter(func.lower(Competence.nom).like(f"%{competence.lower()}%"))
            )

        # Ajouter le filtre par type si sp√©cifi√©
        if type_competence:
            query = query.filter(Competence.type_competence == type_competence)

        consultants = query.distinct().all()

        return consultants  # type: ignore[no-any-return]

    def _find_consultants_by_language(self, langue: str) -> List[Any]:
        """
        Recherche les consultants parlant une langue sp√©cifique.

        Args:
            langue: Nom de la langue √† rechercher (insensible √† la casse)

        Returns:
            Liste des objets Consultant parlant la langue

        Raises:
            SQLAlchemyError: En cas d'erreur de base de donn√©es

        Example:
            >>> consultants = chatbot._find_consultants_by_language("anglais")
            >>> print(f"Trouv√© {len(consultants)} consultants anglophones")

            >>> consultants = chatbot._find_consultants_by_language("espagnol")
            >>> print(f"Trouv√© {len(consultants)} consultants hispanophones")
        """

        # Construction de la requ√™te de base
        with get_database_session() as session:

            consultants = (
                session.query(Consultant)
                .join(ConsultantLangue, Consultant.id == ConsultantLangue.consultant_id)
                .join(Langue, ConsultantLangue.langue_id == Langue.id)
                .filter(func.lower(Langue.nom).like(f"%{langue.lower()}%"))
                .distinct()
                .all()
            )

        return consultants  # type: ignore[no-any-return]

    def _get_missions_by_company(self, entreprise: str) -> List[Mission]:
        """
        R√©cup√®re toutes les missions associ√©es √† une entreprise.

        Args:
            entreprise: Nom de l'entreprise √† rechercher (insensible √† la casse)

        Returns:
            Liste des objets Mission pour cette entreprise

        Raises:
            SQLAlchemyError: En cas d'erreur de base de donn√©es

        Example:
            >>> missions = chatbot._get_missions_by_company("BNP Paribas")
            >>> print(f"BNP Paribas a {len(missions)} missions")
        """
        with get_database_session() as session:
            return (
                session.query(Mission)
                .filter(  # type: ignore[no-any-return]
                    func.lower(Mission.client).like(f"%{entreprise.lower()}%")
                )
                .all()
            )

    def _get_missions_by_consultant(self, consultant_id: int) -> List[Mission]:
        """
        R√©cup√®re toutes les missions d'un consultant sp√©cifique.

        Args:
            consultant_id: Identifiant unique du consultant

        Returns:
            Liste des objets Mission du consultant, tri√©s par date de d√©but d√©croissante

        Raises:
            SQLAlchemyError: En cas d'erreur de base de donn√©es

        Example:
            >>> missions = chatbot._get_missions_by_consultant(123)
            >>> print(f"Consultant 123 a {len(missions)} missions")
            >>> if missions:
            ...     print(f"Derni√®re mission: {missions[0].nom_mission}")
        """
        with get_database_session() as session:
            return (
                session.query(Mission)
                .filter(  # type: ignore[no-any-return]
                    Mission.consultant_id == consultant_id
                )
                .order_by(Mission.date_debut.desc())
                .all()
            )

    def _get_consultant_skills(
        self, consultant_id: int, type_competence: Optional[str] = None
    ) -> List[Dict[str, Any]]:
        """
        R√©cup√®re les comp√©tences d√©taill√©es d'un consultant.

        Args:
            consultant_id: Identifiant unique du consultant
            type_competence: Type de comp√©tence √† filtrer (technique/fonctionnelle) (optionnel)

        Returns:
            Liste de dictionnaires contenant les d√©tails des comp√©tences :
            - nom: Nom de la comp√©tence
            - categorie: Cat√©gorie de la comp√©tence
            - type: Type de comp√©tence (technique/fonctionnelle)
            - niveau_maitrise: Niveau de ma√Ætrise (d√©butant/interm√©diaire/expert)
            - annees_experience: Nombre d'ann√©es d'exp√©rience
            - description: Description de la comp√©tence

        Raises:
            SQLAlchemyError: En cas d'erreur de base de donn√©es

        Example:
            >>> skills = chatbot._get_consultant_skills(123, "technique")
            >>> print(f"Consultant 123 a {len(skills)} comp√©tences techniques")
            >>> for skill in skills:
            ...     print(f"- {skill['nom']}: {skill['niveau_maitrise']}")
        """
        with get_database_session() as session:

            query = (
                session.query(ConsultantCompetence)
                .join(Competence)
                .filter(ConsultantCompetence.consultant_id == consultant_id)
            )

        # Ajouter le filtre par type si sp√©cifi√©
        if type_competence:
            query = query.filter(Competence.type_competence == type_competence)

        consultant_competences = query.all()

        skills = []
        for cc in consultant_competences:
            skills.append(
                {
                    "nom": cc.competence.nom,
                    "categorie": cc.competence.categorie,
                    "type": cc.competence.type_competence,
                    "niveau_maitrise": cc.niveau_maitrise,
                    "annees_experience": cc.annees_experience,
                    "description": cc.competence.description,
                }
            )

        return skills

    def _get_salary_stats(self) -> Dict[str, float]:
        """
        Calcule les statistiques des salaires des consultants.

        Returns:
            Dictionnaire contenant :
            - moyenne: Salaire moyen
            - mediane: Salaire m√©dian
            - minimum: Salaire minimum
            - maximum: Salaire maximum
            - total: Nombre de consultants avec salaire renseign√©

        Raises:
            SQLAlchemyError: En cas d'erreur de base de donn√©es

        Example:
            >>> stats = chatbot._get_salary_stats()
            >>> print(f"Salaire moyen: {stats['moyenne']:,.0f} ‚Ç¨")
            >>> print(f"Salaire m√©dian: {stats['mediane']:,.0f} ‚Ç¨")
        """
        with get_database_session() as session:

            consultants = (
                session.query(Consultant)
                .filter(
                    and_(
                        Consultant.salaire_actuel.isnot(None),
                        Consultant.salaire_actuel > 0,
                    )
                )
                .all()
            )

        if not consultants:
            return {"moyenne": 0, "mediane": 0, "minimum": 0, "maximum": 0, "total": 0}

        salaires = [c.salaire_actuel for c in consultants]
        salaires.sort()

        return {
            "moyenne": sum(salaires) / len(salaires),
            "mediane": salaires[len(salaires) // 2],
            "minimum": min(salaires),
            "maximum": max(salaires),
            "total": len(consultants),
        }

    def _get_general_stats(self) -> Dict[str, Any]:
        """
        Calcule les statistiques g√©n√©rales de la base de donn√©es.

        R√©cup√®re des m√©triques compl√®tes sur consultants, missions, practices,
        CVs et donn√©es financi√®res.

        Returns:
            Dictionnaire contenant toutes les statistiques :
            - consultants_total: Nombre total de consultants
            - consultants_actifs: Nombre de consultants disponibles
            - consultants_inactifs: Nombre de consultants indisponibles
            - missions_total: Nombre total de missions
            - missions_en_cours: Nombre de missions en cours
            - missions_terminees: Nombre de missions termin√©es
            - practices_total: Nombre de practices actives
            - cvs_total: Nombre total de CVs
            - consultants_avec_cv: Nombre de consultants avec au moins un CV
            - tjm_moyen: TJM moyen des missions
            - salaire_moyen: Salaire moyen des consultants
            - cjm_moyen: CJM moyen calcul√©

        Raises:
            SQLAlchemyError: En cas d'erreur de base de donn√©es

        Example:
            >>> stats = chatbot._get_general_stats()
            >>> print(f"Base: {stats['consultants_total']} consultants")
            >>> print(f"Missions: {stats['missions_total']} total")
            >>> print(f"TJM moyen: {stats['tjm_moyen']:.0f} ‚Ç¨")
        """
        from database.models import CV
        from database.models import Practice

        # Consultants
        with get_database_session() as session:

            consultants_total = session.query(Consultant).count()
        with get_database_session() as session:

            consultants_actifs = (
                session.query(Consultant).filter(Consultant.disponibilite).count()
            )
        consultants_inactifs = consultants_total - consultants_actifs

        # Missions
        with get_database_session() as session:

            missions_total = session.query(Mission).count()
        with get_database_session() as session:

            missions_en_cours = (
                session.query(Mission).filter(Mission.statut == "en_cours").count()
            )
        missions_terminees = missions_total - missions_en_cours

        # Practices
        with get_database_session() as session:

            practices_total = session.query(Practice).filter(Practice.actif).count()

        # CVs
        with get_database_session() as session:

            cvs_total = session.query(CV).count()
        with get_database_session() as session:

            consultants_avec_cv = session.query(Consultant).join(CV).distinct().count()

        # TJM moyen
        with get_database_session() as session:

            tjm_moyen = (
                session.query(func.avg(Mission.taux_journalier))
                .filter(Mission.taux_journalier.isnot(None))
                .scalar()
                or 0
            )

        # Salaire moyen et CJM moyen
        with get_database_session() as session:

            salaire_moyen = (
                session.query(func.avg(Consultant.salaire_actuel))
                .filter(Consultant.salaire_actuel.isnot(None))
                .scalar()
                or 0
            )
        cjm_moyen = (salaire_moyen * 1.8 / 216) if salaire_moyen > 0 else 0

        return {
            "consultants_total": consultants_total,
            "consultants_actifs": consultants_actifs,
            "consultants_inactifs": consultants_inactifs,
            "missions_total": missions_total,
            "missions_en_cours": missions_en_cours,
            "missions_terminees": missions_terminees,
            "practices_total": practices_total,
            "cvs_total": cvs_total,
            "consultants_avec_cv": consultants_avec_cv,
            "tjm_moyen": tjm_moyen,
            "salaire_moyen": salaire_moyen,
            "cjm_moyen": cjm_moyen,
        }

    def _handle_availability_question(self, entities: Dict) -> Dict[str, Any]:
        """
        G√®re les questions sur la disponibilit√© des consultants (V1.2.2).

        Analyse la disponibilit√© imm√©diate (ASAP) ou planifi√©e des consultants,
        en tenant compte des missions en cours qui peuvent retarder la disponibilit√©.

        Args:
            entities: Dictionnaire contenant les entit√©s extraites de la question
                     (noms, entreprises, comp√©tences, langues, etc.)

        Returns:
            Dictionnaire contenant :
            - response: R√©ponse format√©e sur la disponibilit√©
            - data: Donn√©es structur√©es sur la disponibilit√©
            - intent: Type d'intention d√©tect√© ("disponibilite")
            - confidence: Niveau de confiance de la r√©ponse (0.0 √† 1.0)

        Raises:
            SQLAlchemyError: En cas d'erreur de base de donn√©es
            AttributeError: Si les donn√©es de disponibilit√© sont malform√©es

        Example:
            >>> entities = {"noms": ["Jean Dupont"]}
            >>> result = chatbot._handle_availability_question(entities)
            >>> print(result["response"])
            üìÖ **Disponibilit√© de Jean Dupont** :
            ‚úÖ **Disponible imm√©diatement (ASAP)**
            üìä **Statut actuel :** ‚úÖ Marqu√© disponible
        """
        # Chercher un consultant sp√©cifique

        # Chercher un consultant sp√©cifique
        consultant = None
        if entities["noms"]:
            nom_complet = " ".join(entities["noms"])
            consultant = self._find_consultant_by_name(nom_complet)

        if consultant:
            try:
                # R√©cup√©rer les donn√©es de disponibilit√©
                with get_database_session() as session:

                    consultant_db = (
                        session.query(Consultant)
                        .filter(Consultant.id == consultant.id)
                        .first()
                    )

                if consultant_db:
                    response = (
                        "üìÖ **Disponibilit√© de "
                        + consultant.prenom
                        + " "
                        + consultant.nom
                        + self.SECTION_HEADER_SUFFIX
                    )

                    # Date de disponibilit√© calcul√©e
                    date_dispo = consultant_db.date_disponibilite
                    if date_dispo == "ASAP":
                        response += "‚úÖ **Disponible imm√©diatement (ASAP)**\n\n"

                        # V√©rifier s'il y a des missions en cours
                        missions_en_cours = [
                            m for m in consultant_db.missions if m.statut == "en_cours"
                        ]
                        if missions_en_cours:
                            response += "‚ö†Ô∏è **Attention :** Le consultant a des missions en cours mais est marqu√© disponible\n"
                            for mission in missions_en_cours:
                                response += (
                                    self.BULLET_POINT_INDENT
                                    + mission.nom_mission
                                    + " chez "
                                    + mission.client
                                    + "\n"
                                )
                    else:
                        response += (
                            "üìÖ **Disponible √† partir du :** "
                            + str(date_dispo)
                            + "\n\n"
                        )

                        # Afficher les missions qui retardent la disponibilit√©
                        from datetime import date

                        missions_futures = [
                            m
                            for m in consultant_db.missions
                            if m.date_fin and m.date_fin > date.today()
                        ]
                        if missions_futures:
                            response += "üéØ **Missions en cours/planifi√©es :**\n"
                            for mission in missions_futures:
                                fin_mission = mission.date_fin.strftime(self.DATE_FORMAT)
                                response += (
                                    self.BULLET_POINT_INDENT
                                    + mission.nom_mission
                                    + " (fin: "
                                    + fin_mission
                                    + ")\n"
                                )

                    # Statut g√©n√©ral
                    response += "\nüìä **Statut actuel :** "
                    if consultant_db.disponibilite:
                        response += "‚úÖ Marqu√© disponible"
                    else:
                        response += "üî¥ Marqu√© occup√©"

                    # Informations compl√©mentaires
                    if consultant_db.grade:
                        response += "\nüéØ **Grade :** " + str(consultant_db.grade)
                    if consultant_db.type_contrat:
                        response += "\nüìù **Contrat :** " + str(
                            consultant_db.type_contrat
                        )

                else:
                    response = (
                        "‚ùå Impossible de r√©cup√©rer les donn√©es de disponibilit√© pour **"
                        + consultant.prenom
                        + " "
                        + consultant.nom
                        + "**."
                    )

            except (SQLAlchemyError, AttributeError, ValueError, TypeError) as e:
                response = (
                    "‚ùå Erreur lors de la r√©cup√©ration des donn√©es de disponibilit√© : "
                    + str(e)
                )

            return {
                "response": response,
                "data": {
                    "consultant": {
                        "nom": consultant.nom,
                        "prenom": consultant.prenom,
                        "date_disponibilite": (
                            getattr(consultant_db, "date_disponibilite", None)
                            if "consultant_db" in locals()
                            else None
                        ),
                        "disponibilite_immediate": (
                            getattr(consultant_db, "disponibilite", None)
                            if "consultant_db" in locals()
                            else None
                        ),
                    }
                },
                "intent": "disponibilite",
                "confidence": 0.9,
            }
        else:
            # Question g√©n√©rale sur les disponibilit√©s
            try:
                with get_database_session() as session:

                    consultants_dispos = (
                        session.query(Consultant).filter(Consultant.disponibilite).all()
                    )
                with get_database_session() as session:

                    consultants_occupes = (
                        session.query(Consultant)
                        .filter(Consultant.disponibilite is False)
                        .all()
                    )

                response = "üìÖ **√âtat des disponibilit√©s** :\n\n"
                response += (
                    "‚úÖ **Disponibles imm√©diatement :** "
                    + str(len(consultants_dispos))
                    + " consultant(s)\n"
                )

                if consultants_dispos:
                    for consultant in consultants_dispos[:5]:  # Limiter √† 5
                        response += (
                            "   ‚Ä¢ " + consultant.prenom + " " + consultant.nom + "\n"
                        )
                    if len(consultants_dispos) > 5:
                        response += (
                            "   ‚Ä¢ ... et "
                            + str(len(consultants_dispos) - 5)
                            + " autre(s)\n"
                        )

                response += (
                    "\nüî¥ **Occup√©s :** "
                    + str(len(consultants_occupes))
                    + " consultant(s)\n"
                )

                if consultants_occupes:
                    for consultant in consultants_occupes[:5]:  # Limiter √† 5
                        date_dispo = consultant.date_disponibilite
                        response += (
                            "   ‚Ä¢ "
                            + consultant.prenom
                            + " "
                            + consultant.nom
                            + " (dispo: "
                            + str(date_dispo)
                            + ")\n"
                        )
                    if len(consultants_occupes) > 5:
                        response += (
                            "   ‚Ä¢ ... et "
                            + str(len(consultants_occupes) - 5)
                            + " autre(s)\n"
                        )

                return {
                    "response": response,
                    "data": {
                        "disponibles": len(consultants_dispos),
                        "occupes": len(consultants_occupes),
                        "total": len(consultants_dispos) + len(consultants_occupes),
                    },
                    "intent": "disponibilite",
                    "confidence": 0.8,
                }

            except (SQLAlchemyError, AttributeError, ValueError, TypeError) as e:
                return {
                    "response": "‚ùå Erreur lors de la r√©cup√©ration des disponibilit√©s : "
                    + str(e),
                    "data": {},
                    "intent": "disponibilite",
                    "confidence": 0.3,
                }

    def _get_consultant_missions_with_tjm(self, consultant_db) -> List:
        """R√©cup√®re les missions avec TJM d'un consultant"""
        if not consultant_db or not consultant_db.missions:
            return []
        return [m for m in consultant_db.missions if m.tjm or m.taux_journalier]

    def _format_mission_tjm_details(self, mission) -> str:
        """Formate les d√©tails d'une mission avec son TJM"""
        tjm = mission.tjm or mission.taux_journalier
        tjm_type = "TJM" if mission.tjm else "TJM (ancien)"
        
        response = f"üéØ **{mission.nom_mission}**\n"
        response += f"{self.BULLET_POINT_INDENT}Client: {mission.client}\n"
        response += f"{self.BULLET_POINT_INDENT}{tjm_type}: {tjm}‚Ç¨\n"

        if mission.date_debut:
            debut = mission.date_debut.strftime(self.DATE_FORMAT)
            if mission.date_fin:
                fin = mission.date_fin.strftime(self.DATE_FORMAT)
                response += f"{self.BULLET_POINT_INDENT}P√©riode: {debut} ‚Üí {fin}\n"
            else:
                response += f"{self.BULLET_POINT_INDENT}D√©but: {debut} (en cours)\n"

        return response + "\n"

    def _calculate_tjm_average(self, missions_avec_tjm) -> tuple:
        """Calcule le TJM moyen √† partir d'une liste de missions"""
        if not missions_avec_tjm:
            return 0, 0
            
        total_tjm = sum(mission.tjm or mission.taux_journalier for mission in missions_avec_tjm)
        count_tjm = len(missions_avec_tjm)
        return total_tjm / count_tjm if count_tjm > 0 else 0, count_tjm

    def _handle_consultant_tjm_inquiry(self, consultant) -> Dict[str, Any]:
        """G√®re les questions TJM pour un consultant sp√©cifique"""
        try:
            with get_database_session() as session:
                consultant_db = (
                    session.query(Consultant)
                    .filter(Consultant.id == consultant.id)
                    .first()
                )

            missions_avec_tjm = self._get_consultant_missions_with_tjm(consultant_db)

            if missions_avec_tjm:
                response = (
                    f"üí∞ **TJM des missions de {consultant.prenom} {consultant.nom}** :\n\n"
                )

                for mission in missions_avec_tjm:
                    response += self._format_mission_tjm_details(mission)

                tjm_moyen, count_tjm = self._calculate_tjm_average(missions_avec_tjm)
                if count_tjm > 1:
                    response += f"üìä **TJM moyen :** {tjm_moyen:.0f}‚Ç¨ (sur {count_tjm} missions)"

            else:
                response = (
                    f"üí∞ **{consultant.prenom} {consultant.nom}** : "
                    "Aucun TJM renseign√© dans les missions"
                )

        except (SQLAlchemyError, AttributeError, ValueError, TypeError, ZeroDivisionError) as e:
            response = f"‚ùå Erreur lors de la r√©cup√©ration des TJM : {str(e)}"

        return {
            "response": response,
            "data": {
                "consultant": {"nom": consultant.nom, "prenom": consultant.prenom}
            },
            "intent": "tjm_mission",
            "confidence": 0.9,
        }

    def _get_global_tjm_statistics(self) -> Dict[str, Any]:
        """Calcule les statistiques globales de TJM"""
        try:
            with get_database_session() as session:
                # TJM moyen avec nouveau champ
                tjm_nouveau_moyen = (
                    session.query(func.avg(Mission.tjm))
                    .filter(Mission.tjm.isnot(None))
                    .scalar() or 0
                )

                # TJM moyen avec ancien champ
                tjm_ancien_moyen = (
                    session.query(func.avg(Mission.taux_journalier))
                    .filter(Mission.taux_journalier.isnot(None))
                    .scalar() or 0
                )

                # Compter les missions avec TJM
                missions_nouveau_tjm = (
                    session.query(Mission).filter(Mission.tjm.isnot(None)).count()
                )

                missions_ancien_tjm = (
                    session.query(Mission)
                    .filter(Mission.taux_journalier.isnot(None))
                    .count()
                )

            response = "üí∞ **Statistiques TJM des missions** :\n\n"

            if missions_nouveau_tjm > 0:
                response += "üÜï **Nouveau format TJM :**\n"
                response += f"{self.BULLET_POINT_INDENT}Missions avec TJM: {missions_nouveau_tjm}\n"
                response += f"{self.BULLET_POINT_INDENT}TJM moyen: {tjm_nouveau_moyen:.0f}‚Ç¨\n\n"

            if missions_ancien_tjm > 0:
                response += "üìä **Ancien format TJM :**\n"
                response += f"{self.BULLET_POINT_INDENT}Missions avec TJM: {missions_ancien_tjm}\n"
                response += f"{self.BULLET_POINT_INDENT}TJM moyen: {tjm_ancien_moyen:.0f}‚Ç¨\n\n"

            # Calcul global
            if missions_nouveau_tjm > 0 or missions_ancien_tjm > 0:
                total_missions = missions_nouveau_tjm + missions_ancien_tjm
                tjm_global = (
                    (tjm_nouveau_moyen * missions_nouveau_tjm) + 
                    (tjm_ancien_moyen * missions_ancien_tjm)
                ) / total_missions
                response += (
                    f"üéØ **TJM global moyen :** {tjm_global:.0f}‚Ç¨ "
                    f"(sur {total_missions} missions)"
                )
            else:
                response = "üí∞ **Aucun TJM renseign√©** dans les missions"

            return {
                "response": response,
                "data": {
                    "tjm_nouveau_moyen": tjm_nouveau_moyen,
                    "tjm_ancien_moyen": tjm_ancien_moyen,
                    "missions_nouveau": missions_nouveau_tjm,
                    "missions_ancien": missions_ancien_tjm,
                },
                "intent": "tjm_mission",
                "confidence": 0.8,
            }

        except (SQLAlchemyError, ZeroDivisionError, TypeError, ValueError) as e:
            return {
                "response": f"‚ùå Erreur lors de la r√©cup√©ration des statistiques TJM : {str(e)}",
                "data": {},
                "intent": "tjm_mission",
                "confidence": 0.3,
            }

    def _handle_mission_tjm_question(self, entities: Dict) -> Dict[str, Any]:
        """
        G√®re les questions sur les TJM (Taux Journalier Moyen) des missions (V1.2.2).

        Analyse les TJM des missions d'un consultant sp√©cifique ou calcule
        les statistiques g√©n√©rales sur les TJM de toutes les missions.

        Args:
            entities: Dictionnaire contenant les entit√©s extraites de la question
                     (noms, entreprises, comp√©tences, langues, etc.)

        Returns:
            Dictionnaire contenant :
            - response: R√©ponse format√©e sur les TJM
            - data: Donn√©es structur√©es sur les TJM
            - intent: Type d'intention d√©tect√© ("tjm_mission")
            - confidence: Niveau de confiance de la r√©ponse (0.0 √† 1.0)
        """
        # Chercher un consultant sp√©cifique
        consultant = None
        if entities.get("noms"):
            nom_complet = " ".join(entities["noms"])
            consultant = self._find_consultant_by_name(nom_complet)

        if consultant:
            return self._handle_consultant_tjm_inquiry(consultant)
        else:
            return self._get_global_tjm_statistics()

    def get_response(self, question: str) -> str:
        """
        Interface simplifi√©e pour obtenir une r√©ponse textuelle du chatbot.

        M√©thode compatible avec les tests existants qui retourne uniquement
        la r√©ponse textuelle sans les m√©tadonn√©es structur√©es.

        Args:
            question: Question de l'utilisateur en langage naturel

        Returns:
            R√©ponse textuelle format√©e du chatbot, ou message d'erreur
            si la question n'est pas comprise ou en cas d'exception

        Raises:
            Aucun: Les exceptions sont captur√©es et retourn√©es comme messages d'erreur

        Example:
            >>> chatbot = ChatbotService()
            >>> response = chatbot.get_response("Quel est le salaire de Jean Dupont ?")
            >>> print(response)
            üí∞ Le salaire de **Jean Dupont** est de **45,000 ‚Ç¨** par an.

            >>> response = chatbot.get_response("Question incompr√©hensible")
            >>> print(response)
            ‚ùì Je n'ai pas compris votre question.
        """
        try:
            result = self.process_question(question)
            response = result.get("response", "‚ùì Je n'ai pas compris votre question.")
            return (
                str(response)
                if response is not None
                else "‚ùì Je n'ai pas compris votre question."
            )
        except (AttributeError, KeyError, TypeError, ValueError) as e:
            return "‚ùå Erreur: " + str(e)

    def __del__(self):
        """
        Destructeur de la classe ChatbotService.

        Nettoie les ressources utilis√©es par le service.
        Note: La gestion des sessions de base de donn√©es est d√©l√©gu√©e
        aux context managers pour √©viter les fuites de m√©moire.
        """
        # Nettoyage des ressources si n√©cessaire
        pass
