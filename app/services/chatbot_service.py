"""
Service Chatbot pour interroger les donn√©es des consultants
Utilise l'IA pour r√©pondre aux questions sur la base de donn√©es
"""

import json
import re
from datetime import datetime
from typing import Any
from typing import Dict
from typing import List
from typing import Optional

import streamlit as st
from sqlalchemy import and_
from sqlalchemy import func
from sqlalchemy import or_
from sqlalchemy.exc import SQLAlchemyError
from sqlalchemy.orm import joinedload

# Imports des services existants
from database.database import get_database_session
from database.models import Competence
from database.models import Consultant
from database.models import ConsultantCompetence
from database.models import ConsultantLangue
from database.models import Langue
from database.models import Mission
from database.models import Practice

# Import de la fonction de calcul de disponibilit√©
try:
    from pages_modules.consultant_info import _calculate_availability_status
except ImportError:
    # Fallback en cas d'import impossible
    def _calculate_availability_status(consultant) -> str:
        return "‚úÖ Disponible" if consultant.disponibilite else "‚ùå Non disponible"


class ChatbotService:
    """Service principal du chatbot pour Consultator"""

    # Constantes pour les cha√Ænes de format r√©p√©t√©es
    SECTION_HEADER_SUFFIX = "** :\n\n"
    YEARS_SUFFIX = " ann√©es\n"
    TOTAL_PREFIX = "\nüìä **Total : "
    CONSULTANT_FOUND_SUFFIX = " consultant(s) trouv√©(s)**"
    STATS_PREFIX = "\n\nüìä **"
    BULLET_POINT = " ‚Ä¢ "
    BULLET_POINT_INDENT = "   ‚Ä¢ "
    DATE_FORMAT = "%d/%m/%Y"

    def __init__(self):
        # Suppression de la session partag√©e pour √©viter les timeouts
        # Chaque m√©thode utilisera une session fra√Æche via context manager
        self.conversation_history = []
        self.last_question = ""

    def _get_session(self):
        """
        Retourne une session de base de donn√©es fra√Æche
        Utilis√© pour √©viter les timeouts de session apr√®s inactivit√©
        """
        return get_database_session()

    def _execute_with_fresh_session(self, query_func):
        """
        Ex√©cute une fonction de requ√™te avec une session fra√Æche
        Args:
            query_func: Fonction qui prend une session en param√®tre et retourne un r√©sultat
        """
        try:
            with get_database_session() as session:
                return query_func(session)
        except Exception as e:
            print(f"Erreur de session dans le chatbot: {e}")
            # Retry avec une nouvelle session
            try:
                with get_database_session() as session:
                    return query_func(session)
            except Exception as e2:
                print(f"Erreur lors du retry: {e2}")
                return None

    def _route_question_to_handler(self, intent: str, entities: dict) -> Dict[str, Any]:
        """Route la question vers le bon handler selon l'intention"""
        if intent == "salaire":
            return self._handle_salary_question(entities)
        elif intent == "experience":
            return self._handle_experience_question(entities)
        elif intent == "profil_professionnel":
            return self._handle_professional_profile_question(entities)
        elif intent == "competences":
            return self._handle_skills_question(entities)
        elif intent == "langues":
            return self._handle_languages_question(entities)
        elif intent == "missions":
            return self._handle_missions_question(entities)
        elif intent == "contact":
            return self._handle_contact_question(entities)
        elif intent == "liste_consultants":
            return self._handle_list_consultants_question()
        elif intent == "practices":
            return self._handle_practices_question(entities)
        elif intent == "cvs":
            return self._handle_cvs_question(entities)
        elif intent == "statistiques":
            return self._handle_stats_question()
        elif intent == "disponibilite":  # Nouveau handler V1.2.2
            return self._handle_availability_question(entities)
        elif intent == "tjm_mission":  # Nouveau handler V1.2.2
            return self._handle_mission_tjm_question(entities)
        elif intent == "recherche_consultant":
            return self._handle_consultant_search(entities)
        else:
            return self._handle_general_question()

    def process_question(self, question: str) -> Dict[str, Any]:
        """
        Traite une question et retourne une r√©ponse structur√©e

        Args:
            question: Question de l'utilisateur

        Returns:
            Dict contenant la r√©ponse, les donn√©es et m√©tadonn√©es
        """
        try:
            # Nettoyer et analyser la question
            clean_question = self._clean_question(question)
            self.last_question = clean_question  # Stocker pour usage dans les handlers
            intent = self._analyze_intent(clean_question)
            entities = self._extract_entities(clean_question)

            # Router vers le bon handler
            return self._route_question_to_handler(intent, entities)

        except Exception as e:
            return {
                "response": f"‚ùå D√©sol√©, j'ai rencontr√© une erreur : {str(e)}",
                "data": None,
                "intent": "error",
                "confidence": 0.0,
            }

    def _clean_question(self, question: str) -> str:
        """Nettoie et normalise la question"""
        # Supprimer la ponctuation excessive
        question = re.sub(r"!{2,}", "!", question)
        question = re.sub(r"\?{2,}", "?", question)

        # Normaliser les espaces
        question = re.sub(r"\s+", " ", question.strip())

        return question.lower()

    def _check_consultant_name_mentioned(self, question: str) -> bool:
        """V√©rifie si un nom de consultant est mentionn√© dans la question"""
        with get_database_session() as session:
            all_consultants = session.query(Consultant).all()
            for consultant in all_consultants:
                if re.search(rf"\b{re.escape(consultant.prenom.lower())}\b", question) or re.search(
                    rf"\b{re.escape(consultant.nom.lower())}\b", question
                ):
                    return True
            return False

    def _get_intent_patterns(self) -> Dict[str, List[str]]:
        """Retourne les patterns pour identifier les intentions"""
        return {
            "salaire": [
                r"salaire",
                r"r√©mun√©ration",
                r"paie",
                r"combien gagne",
                r"revenus",
                r"euros",
                r"‚Ç¨",
                r"salaire de",
                r"gagne",
                r"cjm",
                r"co√ªt journalier",
            ],
            "experience": [
                r"exp√©rience",
                r"experience",
                r"ann√©es d'exp√©rience",
                r"annees d'experience",
                r"anciennet√©",
                r"seniorit√©",
                r"s√©niorit√©",
                r"depuis quand",
                r"depuis combien",
                r"combien d'ann√©es",
                r"combien d'annees",
                r"quel √¢ge",
                r"√¢ge professionnel",
            ],
            "profil_professionnel": [
                r"grade",
                r"niveau",
                r"poste",
                r"fonction",
                r"junior",
                r"confirm√©",
                r"senior",
                r"manager",
                r"directeur",
                r"type contrat",
                r"type de contrat",
                r"contrat",
                r"cdi",
                r"cdd",
                r"stagiaire",
                r"alternant",
                r"ind√©pendant",
                r"freelance",
                r"soci√©t√©",
                r"societe",
                r"quanteam",
                r"asigma",
                r"entreprise",
            ],
            "competences": [
                r"comp√©tences",
                r"competences",
                r"ma√Ætrise",
                r"maitrise",
                r"sait faire",
                r"technologies",
                r"langages",
                r"outils",
                r"expertise",
                r"python",
                r"sql",
                r"java",
                r"quelles\s+(?:\w+\s+)*comp√©tences",
                r"quelles\s+(?:\w+\s+)*competences",
                r"skills",
                r"techno",
                r"conna√Æt",
                r"connait",
            ],
            "langues": [
                r"langues?",
                r"langue",
                r"parle",
                r"parlent",
                r"anglais",
                r"fran√ßais",
                r"espagnol",
                r"allemand",
                r"italien",
                r"bilingue",
                r"niveau\s+(?:\w+\s+)*langue",
                r"parle\s+(?:\w+\s+)*anglais",
                r"qui\s+(?:\w+\s+)*parle",
                r"quelles\s+(?:\w+\s+)*langues",
                r"polyglotte",
                r"linguistique",
            ],
            "missions": [
                r"missions",
                r"mission",
                r"travaille",
                r"chez",
                r"entreprise",
                r"client",
                r"projet",
                r"bnp",
                r"paribas",
                r"soci√©t√© g√©n√©rale",
                r"combien\s+(?:\w+\s+)*missions?",
                r"nombre\s+(?:\w+\s+)*missions?",
                r"projets",
            ],
            "contact": [
                r"mail",
                r"email",
                r"e-mail",
                r"t√©l√©phone",
                r"tel",
                r"num√©ro",
                r"contact",
                r"joindre",
                r"coordonn√©es",
            ],
            "liste_consultants": [
                r"quels sont les consultants",
                r"liste des consultants",
                r"consultants disponibles",
                r"consultants actifs",
                r"tous les consultants",
                r"lister les consultants",
                r"qui sont les consultants",
                r"montrer les consultants",
            ],
            "practices": [
                r"practice",
                r"practices",
                r"qui est dans la practice",
                r"consultants de la practice",
                r"practice data",
                r"practice quant",
                r"√©quipe",
                r"dans quelle practice",
            ],
            "cvs": [
                r"cv",
                r"curriculum",
                r"document",
                r"fichier",
                r"upload",
                r"t√©l√©charg√©",
            ],
            "statistiques": [
                r"combien\s+(?:[\w-]+\s+)*consultants",
                r"nombre\s+(?:[\w-]+\s+)*consultants",
                r"combien\s+(?:[\w-]+\s+)*dans\s+(?:[\w-]+\s+)*base",
                r"nombre",
                r"moyenne",
                r"total",
                r"statistiques",
                r"combien\s+(?:[\w-]+\s+)*missions",
                r"actifs",
                r"inactifs",
                r"tjm moyen",
                r"combien y a",
                r"il y a combien",
            ],
            "disponibilite": [  # Nouvelle intention V1.2.2
                r"disponible",
                r"disponibilit√©",
                r"libre",
                r"quand\s+(?:\w+\s+)*libre",
                r"quand\s+(?:\w+\s+)*disponible",
                r"date\s+(?:\w+\s+)*disponibilit√©",
                r"fin\s+(?:\w+\s+)*mission",
                r"lib√©r√©",
                r"fini",
                r"termine",
                r"asap",
                r"imm√©diatement",
                r"tout de suite",
                r"prochaine disponibilit√©",
            ],
            "tjm_mission": [  # Nouvelle intention V1.2.2
                r"tjm\s+(?:\w+\s+)*mission",
                r"taux\s+(?:\w+\s+)*mission",
                r"prix\s+(?:\w+\s+)*mission",
                r"co√ªt\s+(?:\w+\s+)*mission",
                r"tarif\s+(?:\w+\s+)*mission",
                r"facturation\s+(?:\w+\s+)*mission",
                r"journalier\s+(?:\w+\s+)*mission",
                r"combien\s+(?:\w+\s+)*co√ªte\s+(?:\w+\s+)*mission",
                r"prix\s+(?:\w+\s+)*journ√©e\s+(?:\w+\s+)*mission",
                r"tjm mission",
                r"prix mission",
                r"co√ªt mission",
                r"tarif mission",
                r"taux journalier mission",
                r"combien co√ªte mission",
            ],
            "recherche_consultant": [
                r"qui est",
                r"consultant",
                r"profil",
                r"information sur",
                r"details",
            ],
        }

    def _calculate_intent_scores(self, question: str, intent_patterns: Dict[str, List[str]]) -> Dict[str, int]:
        """Calcule les scores pour chaque intention"""
        intent_scores: Dict[str, int] = {}
        for intent, patterns in intent_patterns.items():
            score: int = 0
            for pattern in patterns:
                if re.search(pattern, question):
                    score += 1
            intent_scores[intent] = score
        return intent_scores

    def _apply_special_intent_rules(
        self, question: str, intent_scores: Dict[str, int], has_consultant_name: bool
    ) -> Optional[str]:
        """Applique les r√®gles sp√©ciales pour d√©terminer l'intention"""

        # V√©rifier les r√®gles pour consultants nomm√©s
        consultant_specific = self._check_consultant_specific_rules(question, intent_scores, has_consultant_name)
        if consultant_specific:
            return consultant_specific

        # V√©rifier les r√®gles g√©n√©rales bas√©es sur les patterns
        pattern_based = self._check_pattern_based_rules(question, intent_scores)
        if pattern_based:
            return pattern_based

        return None

    def _check_consultant_specific_rules(
        self, question: str, intent_scores: Dict[str, int], has_consultant_name: bool
    ) -> Optional[str]:
        """V√©rifie les r√®gles sp√©cifiques aux consultants nomm√©s"""
        if not has_consultant_name:
            return None

        # Si un nom de consultant est mentionn√© et qu'on parle de salaire
        if intent_scores.get("salaire", 0) > 0:
            return "salaire"

        # Si un nom de consultant est mentionn√© et qu'on demande des coordonn√©es
        if intent_scores.get("contact", 0) > 0:
            return "contact"

        # Si un nom de consultant est mentionn√© et qu'on parle de missions
        if intent_scores.get("missions", 0) > 0:
            return "missions"

        # Si le mot "combien" est utilis√© avec un nom de consultant, c'est probablement un salaire
        if re.search(r"combien", question):
            return "salaire"

        return None

    def _check_pattern_based_rules(self, question: str, intent_scores: Dict[str, int]) -> Optional[str]:
        """V√©rifie les r√®gles bas√©es sur les patterns de texte"""

        # NOUVELLE R√àGLE V1.2.2 : Prioriser tjm_mission sur missions si TJM est mentionn√©
        if intent_scores.get("tjm_mission", 0) > 0 and re.search(r"tjm|taux|prix|co√ªt|tarif", question):
            return "tjm_mission"

        # Questions de type "combien de consultants en CDI/CDD"
        if re.search(
            r"combien\s+(?:[\w-]+\s+)*consultants?\s+(?:[\w-]+\s+)*(?:cdi|cdd|stagiaire|alternant|ind√©pendant)",
            question,
        ):
            return "profil_professionnel"

        # Questions de type "qui travaille chez" - utiliser des mots-cl√©s simples pour √©viter ReDoS
        question_lower = question.lower()
        if (
            "qui" in question_lower
            and ("travaille" in question_lower or "est" in question_lower)
            and ("chez" in question_lower or "dans" in question_lower)
            and ("quanteam" in question_lower or "asigma" in question_lower)
        ):
            return "profil_professionnel"

        # Questions de type "combien de missions"
        if re.search(r"combien\s+(?:\w+\s+)*missions?", question):
            return "missions"

        # Questions de type "combien de consultants"
        if re.search(
            r"combien\s+(?:\w+\s+){0,3}(?:consultants?|dans\s+(?:\w+\s+){0,3}base)",
            question,
        ):
            return "statistiques"

        return None

    def _analyze_intent(self, question: str) -> str:
        """Analyse l'intention de la question"""

        # D'abord, v√©rifier s'il y a un nom de consultant mentionn√©
        has_consultant_name = self._check_consultant_name_mentioned(question)

        # Patterns pour identifier les intentions
        intent_patterns = self._get_intent_patterns()

        # Scorer chaque intention
        intent_scores = self._calculate_intent_scores(question, intent_patterns)

        # Appliquer les r√®gles sp√©ciales
        special_intent = self._apply_special_intent_rules(question, intent_scores, has_consultant_name)
        if special_intent:
            return special_intent

        # Retourner l'intention avec le meilleur score
        if max(intent_scores.values()) > 0:
            best_intent = max(intent_scores, key=lambda k: intent_scores[k])
            return best_intent
        else:
            return "general"

    def _extract_consultant_names(self, question: str) -> List[str]:
        """Extrait les noms de consultants de la question"""
        noms = []
        question_lower = question.lower()

        with get_database_session() as session:
            all_consultants = session.query(Consultant).all()

        for consultant in all_consultants:
            # Chercher le pr√©nom dans la question (insensible √† la casse)
            if re.search(rf"\b{re.escape(consultant.prenom.lower())}\b", question_lower):
                noms.append(consultant.prenom)
            # Chercher le nom de famille dans la question
            if re.search(rf"\b{re.escape(consultant.nom.lower())}\b", question_lower):
                noms.append(consultant.nom)
            # Chercher le nom complet
            nom_complet: str = f"{consultant.prenom} {consultant.nom}".lower()
            if nom_complet in question_lower:
                noms.append(f"{consultant.prenom} {consultant.nom}")

        # Supprimer les doublons en gardant l'ordre
        return list(dict.fromkeys(noms))

    def _extract_companies(self, question: str) -> List[str]:
        """Extrait les noms d'entreprises de la question"""
        entreprises = []
        entreprises_connues: List[str] = [
            "bnp paribas",
            "soci√©t√© g√©n√©rale",
            "axa",
            "orange",
            "airbus",
            "renault",
            "peugeot",
            "total",
            "carrefour",
            "cr√©dit agricole",
        ]
        for entreprise in entreprises_connues:
            if entreprise in question:
                entreprises.append(entreprise)
        return entreprises

    def _extract_skills(self, question: str) -> List[str]:
        """Extrait les comp√©tences de la question"""
        from database.models import Competence

        competences = []

        # Comp√©tences techniques pr√©d√©finies
        competences_connues: List[str] = [
            "python",
            "java",
            "javascript",
            "sql",
            "react",
            "angular",
            "node.js",
            "docker",
            "kubernetes",
            "aws",
            "azure",
            "power bi",
            "agile",
            "scrum",
            "finance",
            "devops",
        ]
        for competence in competences_connues:
            if competence in question:
                competences.append(competence)

        # Chercher aussi dans la base de donn√©es des comp√©tences
        with get_database_session() as session:
            all_competences = session.query(Competence).all()
        for competence in all_competences:
            if re.search(rf"\b{re.escape(competence.nom.lower())}\b", question):
                competences.append(competence.nom)

        # Supprimer les doublons
        return list(dict.fromkeys(competences))

    def _extract_languages(self, question: str) -> List[str]:
        """Extrait les langues de la question"""
        langues = []

        # Langues pr√©d√©finies
        langues_connues: List[str] = [
            "fran√ßais",
            "anglais",
            "espagnol",
            "allemand",
            "italien",
            "portugais",
            "chinois",
            "japonais",
            "arabe",
            "russe",
        ]

        # Chercher d'abord dans les langues pr√©d√©finies
        for langue in langues_connues:
            if langue in question:
                langues.append(langue)

        # Chercher dans la base de donn√©es
        with get_database_session() as session:
            all_langues = session.query(Langue).all()
        for langue in all_langues:
            if re.search(rf"\b{re.escape(langue.nom.lower())}\b", question):
                langues.append(langue.nom)

        # Supprimer les doublons
        return list(dict.fromkeys(langues))

    def _extract_amounts(self, question: str) -> List[str]:
        """Extrait les montants de la question"""
        montants_pattern: str = r"(\d+(?:\s*\d{3})*)\s*(?:euros?|‚Ç¨)"
        montants_matches: List[str] = re.findall(montants_pattern, question)
        return [montant.replace(" ", "") for montant in montants_matches]

    def _extract_practices(self, question: str) -> List[str]:
        """Extrait les practices de la question"""
        from database.models import Practice

        practices = []
        with get_database_session() as session:
            all_practices = session.query(Practice).filter(Practice.actif).all()
        for practice in all_practices:
            if re.search(rf"\b{re.escape(practice.nom.lower())}\b", question):
                practices.append(practice.nom)
        return practices

    def _extract_entities(self, question: str) -> Dict[str, List[str]]:
        """Extrait les entit√©s nomm√©es de la question"""
        return {
            "noms": self._extract_consultant_names(question),
            "entreprises": self._extract_companies(question),
            "competences": self._extract_skills(question),
            "langues": self._extract_languages(question),
            "montants": self._extract_amounts(question),
            "practices": self._extract_practices(question),
        }

    def _calculate_cjm(self, salaire: float) -> float:
        """Calcule le CJM (Co√ªt Journalier Moyen) √† partir du salaire"""
        return salaire * 1.8 / 216

    def _format_salary_response(self, consultant, is_cjm_question: bool) -> str:
        """Formate la r√©ponse pour un consultant sp√©cifique selon le type de question"""
        if consultant.salaire_actuel and consultant.salaire_actuel > 0:
            if is_cjm_question:
                # Calculer le CJM
                cjm = self._calculate_cjm(consultant.salaire_actuel)
                response = (
                    "üìà Le CJM (Co√ªt Journalier Moyen) de **"
                    + consultant.prenom
                    + " "
                    + consultant.nom
                    + "** est de **"
                    + f"{cjm:,.0f}"
                    + " ‚Ç¨**."
                )
                response += f"\nüí° Calcul : {consultant.salaire_actuel:,.0f} ‚Ç¨ √ó 1.8 √∑ 216 = {cjm:,.0f} ‚Ç¨"
            else:
                response = (
                    "üí∞ Le salaire de **"
                    + consultant.prenom
                    + " "
                    + consultant.nom
                    + "** est de **"
                    + f"{consultant.salaire_actuel:,.0f}"
                    + " ‚Ç¨** par an."
                )

            if not consultant.disponibilite:
                response += "\n‚ö†Ô∏è Attention : ce consultant est actuellement indisponible."
        else:
            if is_cjm_question:
                response = f"‚ùì D√©sol√©, le CJM de **{consultant.prenom} {consultant.nom}** ne peut pas √™tre calcul√© car le salaire n'est pas renseign√©."
            else:
                response = f"‚ùì D√©sol√©, le salaire de **{consultant.prenom} {consultant.nom}** n'est pas renseign√© dans la base."

        return response

    def _handle_consultant_salary_inquiry(self, consultant, is_cjm_question: bool) -> Dict[str, Any]:
        """G√®re la r√©ponse pour un consultant sp√©cifique"""
        response = self._format_salary_response(consultant, is_cjm_question)

        return {
            "response": response,
            "data": {
                "consultant": {
                    "nom": consultant.nom,
                    "prenom": consultant.prenom,
                    "salaire": consultant.salaire_actuel,
                    "cjm": (self._calculate_cjm(consultant.salaire_actuel) if consultant.salaire_actuel else None),
                    "disponibilite": consultant.disponibilite,
                }
            },
            "intent": "salaire",
            "confidence": 0.9,
        }

    def _handle_general_salary_stats(self) -> Dict[str, Any]:
        """G√®re les statistiques g√©n√©rales de salaire"""
        stats = self._get_salary_stats()
        response = f"""üìä **Statistiques des salaires :**

‚Ä¢ Salaire moyen : **{stats['moyenne']:,.0f} ‚Ç¨**
‚Ä¢ Salaire m√©dian : **{stats['mediane']:,.0f} ‚Ç¨**
‚Ä¢ Salaire minimum : **{stats['minimum']:,.0f} ‚Ç¨**
‚Ä¢ Salaire maximum : **{stats['maximum']:,.0f} ‚Ç¨**
‚Ä¢ Nombre de consultants : **{stats['total']}**"""

        return {
            "response": response,
            "data": {"stats": stats},
            "intent": "salaire",
            "confidence": 0.8,
        }

    def _handle_salary_question(self, entities: Dict) -> Dict[str, Any]:
        """G√®re les questions sur les salaires et le CJM"""

        # D√©tecter si c'est une question sur le CJM
        is_cjm_question = "cjm" in self.last_question.lower() or "co√ªt journalier" in self.last_question.lower()

        # Si un nom est mentionn√©, chercher ce consultant sp√©cifique
        if entities["noms"]:
            nom_recherche: str = entities["noms"][0]
            consultant = self._find_consultant_by_name(nom_recherche)

            if consultant:
                return self._handle_consultant_salary_inquiry(consultant, is_cjm_question)
            else:
                return {
                    "response": f"‚ùå Je n'ai pas trouv√© de consultant nomm√© **{nom_recherche}** dans la base de donn√©es.",
                    "data": None,
                    "intent": "salaire",
                    "confidence": 0.7,
                }

        # Sinon, donner des statistiques g√©n√©rales
        else:
            return self._handle_general_salary_stats()

    def _calculate_company_seniority(self, consultant_db) -> float:
        """Calcule l'anciennet√© dans la soci√©t√© en ann√©es"""
        from datetime import date

        if not consultant_db.date_entree_societe:
            return 0

        today = date.today()
        if consultant_db.date_sortie_societe:
            fin_periode = consultant_db.date_sortie_societe
        else:
            fin_periode = today
        delta_societe = fin_periode - consultant_db.date_entree_societe
        return round(delta_societe.days / 365.25, 1)

    def _format_experience_details(self, consultant, consultant_db) -> str:
        """Formate les d√©tails d'exp√©rience d'un consultant"""
        experience_annees = consultant_db.experience_annees

        response = "üìä **Exp√©rience de " + consultant.prenom + " " + consultant.nom + self.SECTION_HEADER_SUFFIX
        response += f"üöÄ **Premi√®re mission :** {consultant_db.date_premiere_mission.strftime(self.DATE_FORMAT)}\n"
        response += f"‚è±Ô∏è **Exp√©rience totale :** **{experience_annees} ann√©es**\n"

        # Ajouter des informations contextuelles
        if consultant_db.grade:
            response += f"üéØ **Grade actuel :** {consultant_db.grade}\n"

        if consultant_db.societe:
            response += f"üè¢ **Soci√©t√© :** {consultant_db.societe}\n"

        if consultant_db.date_entree_societe:
            response += (
                f"üìÖ **Date d'entr√©e soci√©t√© :** {consultant_db.date_entree_societe.strftime(self.DATE_FORMAT)}\n"
            )
            # Calculer l'anciennet√© dans la soci√©t√©
            anciennete_societe = self._calculate_company_seniority(consultant_db)
            response += f"üè¢ **Anciennet√© soci√©t√© :** {anciennete_societe} ann√©es\n"

        # Statut soci√©t√©
        statut = consultant_db.statut_societe
        if statut == "En poste":
            response += f"‚úÖ **Statut :** {statut}"
        elif statut == "D√©part pr√©vu":
            response += f"‚ö†Ô∏è **Statut :** {statut}"
        else:
            response += f"‚ùå **Statut :** {statut}"

        return response

    def _build_consultant_experience_data(self, consultant, consultant_db) -> Dict:
        """Construit les donn√©es structur√©es d'exp√©rience d'un consultant"""
        return {
            "nom": consultant.nom,
            "prenom": consultant.prenom,
            "experience_annees": (getattr(consultant_db, "experience_annees", None) if consultant_db else None),
            "date_premiere_mission": (
                consultant_db.date_premiere_mission.isoformat()
                if consultant_db and consultant_db.date_premiere_mission
                else None
            ),
            "grade": (getattr(consultant_db, "grade", None) if consultant_db else None),
            "societe": (getattr(consultant_db, "societe", None) if consultant_db else None),
        }

    def _handle_consultant_experience_inquiry(self, consultant) -> Dict[str, Any]:
        """G√®re les questions d'exp√©rience pour un consultant sp√©cifique"""
        try:
            with get_database_session() as session:
                consultant_db = (
                    session.query(Consultant)
                    .options(joinedload(Consultant.langues).joinedload(ConsultantLangue.langue))
                    .filter(Consultant.id == consultant.id)
                    .first()
                )

                if consultant_db:
                    if consultant_db.date_premiere_mission:
                        response = self._format_experience_details(consultant, consultant_db)
                    else:
                        response = f"‚ùì L'exp√©rience de **{consultant.prenom} {consultant.nom}** ne peut pas √™tre calcul√©e car la date de premi√®re mission n'est pas renseign√©e."
                else:
                    response = f"‚ùå Impossible de r√©cup√©rer les donn√©es de **{consultant.prenom} {consultant.nom}**."

        except (ValueError, TypeError, AttributeError, KeyError) as e:
            response = f"‚ùå Erreur lors de la r√©cup√©ration des donn√©es d'exp√©rience : {str(e)}"
            consultant_db = None

        return {
            "response": response,
            "data": {"consultant": self._build_consultant_experience_data(consultant, consultant_db)},
            "intent": "experience",
            "confidence": 0.9,
        }

    def _calculate_experience_statistics(self, consultants_avec_experience) -> str:
        """Calcule et formate les statistiques d'exp√©rience g√©n√©rales"""
        experiences = [c.experience_annees for c in consultants_avec_experience]

        response = "üìä **Statistiques d'exp√©rience :**\n\n"
        response += f"‚Ä¢ **Consultants avec exp√©rience renseign√©e :** {len(consultants_avec_experience)}\n"
        response += "‚Ä¢ **Exp√©rience moyenne :** " + str(sum(experiences) / len(experiences)) + self.YEARS_SUFFIX
        response += "‚Ä¢ **Exp√©rience minimum :** " + str(min(experiences)) + self.YEARS_SUFFIX
        response += "‚Ä¢ **Exp√©rience maximum :** " + str(max(experiences)) + self.YEARS_SUFFIX

        # Top 3 des plus exp√©riment√©s
        top_experienced = sorted(
            consultants_avec_experience,
            key=lambda c: c.experience_annees,
            reverse=True,
        )[:3]
        response += "\nüèÜ **Top 3 des plus exp√©riment√©s :**\n"
        for i, consultant in enumerate(top_experienced, 1):
            response += (
                str(i)
                + ". **"
                + consultant.prenom
                + " "
                + consultant.nom
                + "** : "
                + str(consultant.experience_annees)
                + self.YEARS_SUFFIX
            )

        return response

    def _handle_general_experience_stats(self) -> Dict[str, Any]:
        """G√®re les statistiques g√©n√©rales d'exp√©rience"""
        try:
            with get_database_session() as session:
                consultants_avec_experience = (
                    session.query(Consultant).filter(Consultant.date_premiere_mission.isnot(None)).all()
                )

                if consultants_avec_experience:
                    response = self._calculate_experience_statistics(consultants_avec_experience)
                else:
                    response = "‚ùì Aucun consultant n'a d'exp√©rience renseign√©e dans la base."

        except (
            SQLAlchemyError,
            OSError,
            ValueError,
            TypeError,
            AttributeError,
            KeyError,
        ) as e:
            response = f"‚ùå Erreur lors du calcul des statistiques : {str(e)}"
            consultants_avec_experience = []

        return {
            "response": response,
            "data": {"consultants_count": len(consultants_avec_experience)},
            "intent": "experience",
            "confidence": 0.8,
        }

    def _handle_experience_question(self, entities: Dict) -> Dict[str, Any]:
        """G√®re les questions sur l'exp√©rience des consultants"""

        # Si un nom est mentionn√©, chercher ce consultant sp√©cifique
        if entities["noms"]:
            nom_recherche: str = entities["noms"][0]
            consultant = self._find_consultant_by_name(nom_recherche)

            if consultant:
                return self._handle_consultant_experience_inquiry(consultant)
            else:
                return {
                    "response": f"‚ùå Je n'ai pas trouv√© de consultant nomm√© **{nom_recherche}** dans la base de donn√©es.",
                    "data": None,
                    "intent": "experience",
                    "confidence": 0.7,
                }

        # Statistiques g√©n√©rales sur l'exp√©rience
        else:
            return self._handle_general_experience_stats()

    def _get_profile_response_for_grade(self, consultant, consultant_db):
        """Retourne la r√©ponse pour une question sur le grade"""
        return f"üéØ **Grade de {consultant.prenom} {consultant.nom}** : **{consultant_db.grade or 'Non renseign√©'}**"

    def _get_profile_response_for_contract(self, consultant, consultant_db):
        """Retourne la r√©ponse pour une question sur le type de contrat"""
        return f"üìã **Type de contrat de {consultant.prenom} {consultant.nom}** : **{consultant_db.type_contrat or 'Non renseign√©'}**"

    def _get_profile_response_for_company(self, consultant, consultant_db):
        """Retourne la r√©ponse pour une question sur la soci√©t√©"""
        response = (
            f"üè¢ **Soci√©t√© de {consultant.prenom} {consultant.nom}** : **{consultant_db.societe or 'Non renseign√©'}**"
        )
        if consultant_db.date_entree_societe:
            response += f"\nüìÖ **Date d'entr√©e :** {consultant_db.date_entree_societe.strftime(self.DATE_FORMAT)}"
        if consultant_db.date_sortie_societe:
            response += f"\nüìÖ **Date de sortie :** {consultant_db.date_sortie_societe.strftime(self.DATE_FORMAT)}"
        else:
            response += "\n‚úÖ **Toujours en poste**"
        return response

    def _get_complete_profile_response(self, consultant, consultant_db):
        """Retourne le profil professionnel complet"""
        response = f"üëî **Profil professionnel de {consultant.prenom} {consultant.nom}{self.SECTION_HEADER_SUFFIX}"
        response += f"üéØ **Grade :** {consultant_db.grade or 'Non renseign√©'}\n"
        response += f"üìã **Type de contrat :** {consultant_db.type_contrat or 'Non renseign√©'}\n"
        response += f"üè¢ **Soci√©t√© :** {consultant_db.societe or 'Non renseign√©'}\n"

        if consultant_db.date_entree_societe:
            response += (
                f"üìÖ **Date d'entr√©e soci√©t√© :** {consultant_db.date_entree_societe.strftime(self.DATE_FORMAT)}\n"
            )

        if consultant_db.date_sortie_societe:
            response += (
                f"üìÖ **Date de sortie soci√©t√© :** {consultant_db.date_sortie_societe.strftime(self.DATE_FORMAT)}\n"
            )
        else:
            response += "‚úÖ **Statut :** Toujours en poste\n"

        if consultant_db.experience_annees:
            response += f"‚è±Ô∏è **Exp√©rience :** {consultant_db.experience_annees}{self.YEARS_SUFFIX}"

        # Informations salariales si disponibles
        if consultant_db.salaire_actuel:
            cjm = consultant_db.salaire_actuel * 1.8 / 216
            response += f"üí∞ **Salaire :** {consultant_db.salaire_actuel:,.0f} ‚Ç¨/an\n"
            response += f"üìà **CJM :** {cjm:,.0f} ‚Ç¨/jour"

        return response

    def _handle_individual_profile_question(self, entities: Dict, question_lower: str) -> Dict[str, Any]:
        """G√®re les questions de profil pour un consultant sp√©cifique"""
        nom_recherche: str = entities["noms"][0]
        consultant = self._find_consultant_by_name(nom_recherche)

        if not consultant:
            return {
                "response": f"‚ùå Je n'ai pas trouv√© de consultant nomm√© **{nom_recherche}** dans la base de donn√©es.",
                "data": None,
                "intent": "profil_professionnel",
                "confidence": 0.7,
            }

        try:
            with get_database_session() as session:
                consultant_db = session.query(Consultant).filter(Consultant.id == consultant.id).first()

                if not consultant_db:
                    response = f"‚ùå Impossible de r√©cup√©rer les donn√©es de **{consultant.prenom} {consultant.nom}**."
                else:
                    # D√©terminer le type d'information demand√©e
                    if any(word in question_lower for word in ["grade", "niveau", "poste", "fonction"]):
                        response = self._get_profile_response_for_grade(consultant, consultant_db)
                    elif any(word in question_lower for word in ["contrat", "type contrat", "cdi", "cdd"]):
                        response = self._get_profile_response_for_contract(consultant, consultant_db)
                    elif any(
                        word in question_lower
                        for word in [
                            "soci√©t√©",
                            "societe",
                            "entreprise",
                            "quanteam",
                            "asigma",
                        ]
                    ):
                        response = self._get_profile_response_for_company(consultant, consultant_db)
                    else:
                        response = self._get_complete_profile_response(consultant, consultant_db)

        except (SQLAlchemyError, AttributeError, ValueError, TypeError) as e:
            response = f"‚ùå Erreur lors de la r√©cup√©ration du profil : {str(e)}"
            consultant_db = None

        return {
            "response": response,
            "data": {
                "consultant": {
                    "nom": consultant.nom,
                    "prenom": consultant.prenom,
                    "grade": (getattr(consultant_db, "grade", None) if consultant_db else None),
                    "type_contrat": (getattr(consultant_db, "type_contrat", None) if consultant_db else None),
                    "societe": (getattr(consultant_db, "societe", None) if consultant_db else None),
                }
            },
            "intent": "profil_professionnel",
            "confidence": 0.9,
        }

    def _group_consultants_by_grade(self, consultants) -> Dict[str, List]:
        """Groupe les consultants par grade"""
        grades_count: Dict[str, List[Consultant]] = {}
        for consultant in consultants:
            grade = consultant.grade
            if grade not in grades_count:
                grades_count[grade] = []
            grades_count[grade].append(consultant)
        return grades_count

    def _handle_grade_statistics(self, session) -> str:
        """G√®re les statistiques par grade"""
        consultants = session.query(Consultant).filter(Consultant.grade.isnot(None)).all()

        if consultants:
            grades_count = self._group_consultants_by_grade(consultants)

            response = "üéØ **R√©partition par grade :**\n\n"
            for grade, consultants_list in grades_count.items():
                response += f"‚Ä¢ **{grade}** : {len(consultants_list)} consultant(s)\n"
                if len(consultants_list) <= 5:  # Afficher les noms si pas trop nombreux
                    for c in consultants_list:
                        response += f"  - {c.prenom} {c.nom}\n"
        else:
            response = "‚ùì Aucun consultant n'a de grade renseign√©."

        return response

    def _count_consultants_by_contract_type(self, consultants, contract_type: str) -> int:
        """Compte les consultants d'un type de contrat sp√©cifique"""
        if contract_type.upper() == "CDI":
            return len([c for c in consultants if c.type_contrat and c.type_contrat.upper() == "CDI"])
        elif contract_type.upper() == "CDD":
            return len([c for c in consultants if c.type_contrat and c.type_contrat.upper() == "CDD"])
        elif contract_type.lower() == "stagiaire":
            return len([c for c in consultants if c.type_contrat and c.type_contrat.lower() == "stagiaire"])
        return 0

    def _handle_contract_count_query(self, consultants, question_lower: str) -> str:
        """G√®re les questions de comptage de consultants par contrat"""
        if "cdi" in question_lower:
            count = self._count_consultants_by_contract_type(consultants, "CDI")
            return f"üìã **{count} consultant(s) en CDI**"
        elif "cdd" in question_lower:
            count = self._count_consultants_by_contract_type(consultants, "CDD")
            return f"üìã **{count} consultant(s) en CDD**"
        elif "stagiaire" in question_lower:
            count = self._count_consultants_by_contract_type(consultants, "stagiaire")
            return f"üìã **{count} consultant(s) stagiaire(s)**"
        else:
            return self._get_all_contract_counts(consultants)

    def _get_all_contract_counts(self, consultants) -> str:
        """Retourne toutes les statistiques de contrats"""
        contrats_count: Dict[str, int] = {}
        for consultant in consultants:
            contrat = consultant.type_contrat
            if contrat not in contrats_count:
                contrats_count[contrat] = 0
            contrats_count[contrat] += 1

        response = "üìã **Nombre de consultants par type de contrat :**\n\n"
        for contrat, count in contrats_count.items():
            response += f"‚Ä¢ **{contrat}** : {count} consultant(s)\n"
        return response

    def _get_contract_detailed_breakdown(self, consultants) -> str:
        """Retourne la r√©partition d√©taill√©e par type de contrat"""
        contrats_list: Dict[str, List[Consultant]] = {}
        for consultant in consultants:
            contrat = consultant.type_contrat
            if contrat not in contrats_list:
                contrats_list[contrat] = []
            contrats_list[contrat].append(consultant)

        response = "üìã **R√©partition par type de contrat :**\n\n"
        for contrat, consultants_list in contrats_list.items():
            response += f"‚Ä¢ **{contrat}** : {len(consultants_list)} consultant(s)\n"
            if len(consultants_list) <= 5:  # Afficher les noms si pas trop nombreux
                for c in consultants_list:
                    response += f"  - {c.prenom} {c.nom}\n"
        return response

    def _handle_contract_statistics(self, session, question_lower: str) -> str:
        """G√®re les statistiques par type de contrat"""
        consultants = session.query(Consultant).filter(Consultant.type_contrat.isnot(None)).all()

        # Si c'est une question "combien de consultants en CDI/CDD"
        if any(word in question_lower for word in ["combien"]):
            return self._handle_contract_count_query(consultants, question_lower)
        else:
            # R√©partition compl√®te par type de contrat
            if consultants:
                return self._get_contract_detailed_breakdown(consultants)
            else:
                return "‚ùì Aucun consultant n'a de type de contrat renseign√©."

    def _handle_company_statistics(self, session, question_lower: str) -> str:
        """G√®re les statistiques par soci√©t√©"""
        consultants = self._get_consultants_with_company(session)

        if self._is_specific_company_search(question_lower):
            return self._handle_specific_company_search(consultants, question_lower)
        else:
            return self._handle_general_company_statistics(consultants)

    def _get_consultants_with_company(self, session) -> List:
        """R√©cup√®re tous les consultants ayant une soci√©t√© renseign√©e"""
        return session.query(Consultant).filter(Consultant.societe.isnot(None)).all()

    def _is_specific_company_search(self, question_lower: str) -> bool:
        """V√©rifie si la question concerne une soci√©t√© sp√©cifique"""
        return any(word in question_lower for word in ["quanteam", "asigma"])

    def _handle_specific_company_search(self, consultants: List, question_lower: str) -> str:
        """G√®re la recherche pour une soci√©t√© sp√©cifique"""
        societe_recherchee = self._extract_target_company(question_lower)
        consultants_societe = self._filter_consultants_by_company(consultants, societe_recherchee)

        if consultants_societe:
            return self._format_specific_company_response(consultants_societe, societe_recherchee)
        else:
            return f"‚ùì Aucun consultant trouv√© chez {societe_recherchee}."

    def _extract_target_company(self, question_lower: str) -> str:
        """Extrait le nom de la soci√©t√© recherch√©e"""
        return "Quanteam" if "quanteam" in question_lower else "Asigma"

    def _filter_consultants_by_company(self, consultants: List, target_company: str) -> List:
        """Filtre les consultants par soci√©t√©"""
        return [c for c in consultants if c.societe and c.societe.lower() == target_company.lower()]

    def _format_specific_company_response(self, consultants_societe: List, societe_recherchee: str) -> str:
        """Formate la r√©ponse pour une soci√©t√© sp√©cifique"""
        response = f"üè¢ **Consultants chez {societe_recherchee}** :\n\n"

        for i, consultant in enumerate(consultants_societe, 1):
            response += self._format_consultant_company_line(consultant, i)

        response += self.TOTAL_PREFIX + str(len(consultants_societe)) + self.CONSULTANT_FOUND_SUFFIX
        return response

    def _format_consultant_company_line(self, consultant, index: int) -> str:
        """Formate une ligne consultant pour l'affichage par soci√©t√©"""
        status_icon = "üü¢" if consultant.disponibilite else "üî¥"
        line = f"{index}. {status_icon} **{consultant.prenom} {consultant.nom}**"

        if consultant.grade:
            line += f" - {consultant.grade}"
        if consultant.type_contrat:
            line += f" ({consultant.type_contrat})"
        line += "\n"

        return line

    def _handle_general_company_statistics(self, consultants: List) -> str:
        """G√®re les statistiques g√©n√©rales par soci√©t√©"""
        if not consultants:
            return "‚ùì Aucun consultant n'a de soci√©t√© renseign√©e."

        societes_count = self._group_consultants_by_company(consultants)
        return self._format_general_company_statistics(societes_count)

    def _group_consultants_by_company(self, consultants: List) -> Dict[str, List]:
        """Groupe les consultants par soci√©t√©"""
        societes_count: Dict[str, List[Consultant]] = {}
        for consultant in consultants:
            societe = consultant.societe
            if societe not in societes_count:
                societes_count[societe] = []
            societes_count[societe].append(consultant)
        return societes_count

    def _format_general_company_statistics(self, societes_count: Dict[str, List]) -> str:
        """Formate les statistiques g√©n√©rales par soci√©t√©"""
        response = "üè¢ **R√©partition par soci√©t√© :**\n\n"

        for societe, consultants_list in societes_count.items():
            response += f"‚Ä¢ **{societe}** : {len(consultants_list)} consultant(s)\n"
            if len(consultants_list) <= 5:  # Afficher les noms si pas trop nombreux
                response += self._format_company_consultant_details(consultants_list)

        return response

    def _format_company_consultant_details(self, consultants_list: List) -> str:
        """Formate les d√©tails des consultants pour une soci√©t√©"""
        details = ""
        for c in consultants_list:
            details += f"  - {c.prenom} {c.nom}\n"
        return details

    def _handle_professional_profile_question(self, entities: Dict) -> Dict[str, Any]:
        """G√®re les questions sur le profil professionnel (grade, type contrat, soci√©t√©)"""
        question_lower: str = self.last_question.lower()

        # Si un nom est mentionn√©, chercher ce consultant sp√©cifique
        if entities["noms"]:
            return self._handle_individual_profile_question(entities, question_lower)

        # Questions g√©n√©rales par crit√®re
        else:
            try:
                with get_database_session() as session:
                    if any(
                        word in question_lower
                        for word in [
                            "grade",
                            "niveau",
                            "junior",
                            "confirm√©",
                            "manager",
                            "directeur",
                        ]
                    ):
                        response = self._handle_grade_statistics(session)
                    elif any(word in question_lower for word in ["contrat", "cdi", "cdd", "stagiaire"]):
                        response = self._handle_contract_statistics(session, question_lower)
                    elif any(
                        word in question_lower
                        for word in [
                            "soci√©t√©",
                            "societe",
                            "quanteam",
                            "asigma",
                            "qui travaille",
                            "qui est",
                        ]
                    ):
                        response = self._handle_company_statistics(session, question_lower)
                    else:
                        response = "ü§î Pr√©cisez quel aspect du profil professionnel vous int√©resse : grade, type de contrat, ou soci√©t√© ?"

            except (
                SQLAlchemyError,
                AttributeError,
                ValueError,
                TypeError,
                KeyError,
            ) as e:
                response = f"‚ùå Erreur lors de la r√©cup√©ration des donn√©es : {str(e)}"

            return {
                "response": response,
                "data": None,
                "intent": "profil_professionnel",
                "confidence": 0.8,
            }

    def _detect_skill_type(self, question_lower: str) -> Optional[str]:
        """D√©tecte le type de comp√©tence demand√© dans la question"""
        if any(
            word in question_lower
            for word in [
                "comp√©tences techniques",
                "technique",
                "technologie",
                "programmation",
            ]
        ):
            return "technique"
        elif any(
            word in question_lower
            for word in [
                "comp√©tences fonctionnelles",
                "fonctionnelle",
                "m√©tier",
                "bancaire",
                "finance",
            ]
        ):
            return "fonctionnelle"
        return None

    def _extract_skill_from_question(self, question_lower: str) -> Optional[str]:
        """Extrait le nom de la comp√©tence d'une question 'qui ma√Ætrise'"""
        patterns = [
            r"qui\s+ma√Ætrise\s+(.+?)(?:\?|$)",
            r"qui\s+sait\s+(.+?)(?:\?|$)",
            r"qui\s+conna√Æt\s+(.+?)(?:\?|$)",
            r"qui\s+connait\s+(.+?)(?:\?|$)",
            r"qui\s+a\s+(.+?)(?:\?|$)",
            r"qui\s+poss√®de\s+(.+?)(?:\?|$)",
        ]

        for pattern in patterns:
            match = re.search(pattern, question_lower)
            if match:
                competence_found = match.group(1).strip()
                # Nettoyer les articles et pr√©positions (protection ReDoS avec limites strictes)
                # Limite la longueur de la cha√Æne pour √©viter le backtracking excessif
                if len(competence_found) <= 100:  # Protection ReDoS
                    competence_found = re.sub(r"^(?:le|la|les|du|de|des|en|une?)\s+", "", competence_found, count=1)
                    competence_found = re.sub(r"\s+(?:comp√©tence|skill)s?\Z", "", competence_found, count=1)
                return competence_found
        return None

    def _handle_specific_skill_search(self, competence: str, type_competence: Optional[str]) -> Dict[str, Any]:
        """G√®re la recherche de consultants ayant une comp√©tence sp√©cifique"""
        consultants = self._find_consultants_by_skill(competence, type_competence)

        if consultants:
            noms = [f"**{c.prenom} {c.nom}**" for c in consultants]
            response = f"üéØ Consultants ma√Ætrisant **{competence.title()}** :\n\n"
            response += "\n".join([f"‚Ä¢ {nom}" for nom in noms])
            response += self.STATS_PREFIX + str(len(consultants)) + self.CONSULTANT_FOUND_SUFFIX
        else:
            response = f"‚ùå Aucun consultant ne ma√Ætrise **{competence}** dans notre base."

        return {
            "response": response,
            "data": {"consultants": [{"nom": c.nom, "prenom": c.prenom} for c in consultants]},
            "intent": "competences",
            "confidence": 0.9,
        }

    def _handle_consultant_skills_inquiry(self, nom: str, type_competence: Optional[str]) -> Dict[str, Any]:
        """G√®re les questions sur les comp√©tences d'un consultant sp√©cifique"""
        consultant = self._find_consultant_by_name(nom)

        if not consultant:
            return self._format_consultant_not_found_response(nom)

        skills = self._get_consultant_skills(consultant.id, type_competence)

        if not skills:
            return self._format_no_skills_response(consultant)

        response = self._format_consultant_skills_response(consultant, skills)

        return {
            "response": response,
            "data": {
                "consultant": consultant.nom,
                "skills_count": len(skills),
            },
            "intent": "competences",
            "confidence": 0.9,
        }

    def _format_consultant_not_found_response(self, nom: str) -> Dict[str, Any]:
        """Formate la r√©ponse quand le consultant n'est pas trouv√©"""
        return {
            "response": f"‚ùå Consultant **{nom}** introuvable.",
            "data": {
                "consultant": None,
                "skills_count": 0,
            },
            "intent": "competences",
            "confidence": 0.9,
        }

    def _format_no_skills_response(self, consultant) -> Dict[str, Any]:
        """Formate la r√©ponse quand aucune comp√©tence n'est trouv√©e"""
        return {
            "response": f"‚ùå Aucune comp√©tence enregistr√©e pour **{consultant.prenom} {consultant.nom}**.",
            "data": {
                "consultant": consultant.nom,
                "skills_count": 0,
            },
            "intent": "competences",
            "confidence": 0.9,
        }

    def _format_consultant_skills_response(self, consultant, skills: List) -> str:
        """Formate la r√©ponse compl√®te des comp√©tences d'un consultant"""
        response = f"üéØ **Comp√©tences de {consultant.prenom} {consultant.nom} :**\n\n"

        categories = self._group_skills_by_category(skills)
        response += self._format_skills_by_category(categories)
        response += f"üìä **Total : {len(skills)} comp√©tence(s)**"

        return response

    def _group_skills_by_category(self, skills: List) -> Dict[str, List[Dict[str, Any]]]:
        """Groupe les comp√©tences par cat√©gorie"""
        categories: Dict[str, List[Dict[str, Any]]] = {}
        for skill in skills:
            categorie = skill["categorie"] or "Autre"
            if categorie not in categories:
                categories[categorie] = []
            categories[categorie].append(skill)
        return categories

    def _format_skills_by_category(self, categories: Dict[str, List[Dict[str, Any]]]) -> str:
        """Formate l'affichage des comp√©tences par cat√©gorie"""
        response = ""
        for categorie, competences in categories.items():
            response += f"**üîπ {categorie.title()} :**\n"
            response += self._format_category_skills(competences)
            response += "\n"
        return response

    def _format_category_skills(self, competences: List[Dict[str, Any]]) -> str:
        """Formate les comp√©tences d'une cat√©gorie"""
        formatted = ""
        for comp in competences:
            niveau_emoji = self._get_skill_level_emoji(comp["niveau_maitrise"])
            experience_text = self._format_experience_text(comp["annees_experience"])
            formatted += f"  {niveau_emoji} **{comp['nom']}** - {comp['niveau_maitrise'].title()}{experience_text}\n"
        return formatted

    def _get_skill_level_emoji(self, niveau_maitrise: str) -> str:
        """Retourne l'emoji correspondant au niveau de ma√Ætrise"""
        return {
            "debutant": "üü°",
            "intermediaire": "üü†",
            "expert": "üî¥",
        }.get(niveau_maitrise, "‚ö™")

    def _format_experience_text(self, annees_experience: Optional[float]) -> str:
        """Formate le texte d'exp√©rience en ann√©es"""
        if not annees_experience or annees_experience <= 0:
            return ""

        if annees_experience == 1:
            return f" ({annees_experience} an)"
        else:
            return f" ({annees_experience:.0f} ans)"

    def _handle_skills_question(self, entities: Dict) -> Dict[str, Any]:
        """G√®re les questions sur les comp√©tences"""

        # D√©tecter le type de comp√©tences demand√©
        question_lower: str = self.last_question.lower()
        type_competence = self._detect_skill_type(question_lower)

        # Si une comp√©tence sp√©cifique est mentionn√©e
        if entities["competences"]:
            return self._handle_specific_skill_search(entities["competences"][0], type_competence)

        # Recherche dynamique de comp√©tence dans la question
        elif any(word in question_lower for word in ["qui ma√Ætrise", "qui sait", "qui conna√Æt", "qui connait"]):
            competence_found = self._extract_skill_from_question(question_lower)

            if competence_found:
                return self._handle_specific_skill_search(competence_found, type_competence)

        # Question g√©n√©rale sur les comp√©tences d'un consultant
        elif entities["noms"]:
            return self._handle_consultant_skills_inquiry(entities["noms"][0], type_competence)

        return {
            "response": "ü§î Pouvez-vous pr√©ciser quelle comp√©tence ou quel consultant vous int√©resse ?",
            "data": None,
            "intent": "competences",
            "confidence": 0.5,
        }

    def _extract_consultant_name_from_language_question(self, question_lower: str) -> Optional[str]:
        """Extrait le nom du consultant d'une question sur les langues"""
        patterns = [
            r"quelles?\s+langues?\s+parle\s+(\w+)",
            r"langues?\s+parle\s+(\w+)",
            r"langues?\s+de\s+(\w+)",
            r"(\w+)\s+parle\s+quelles?\s+langues?",
            r"quelles?\s+sont\s+les\s+langues?\s+de\s+(\w+)",
        ]

        for pattern in patterns:
            match = re.search(pattern, question_lower)
            if match:
                return match.group(1)
        return None

    def _extract_language_from_question(self, question_lower: str) -> Optional[str]:
        """Extrait le nom de la langue d'une question 'qui parle'"""
        patterns = [
            r"qui\s+parle\s+(.+?)(?:\?|$)",
            r"parlent\s+(.+?)(?:\?|$)",
            r"qui\s+(?:\w+\s+)*parle\s+(?:\w+\s+)*(.+?)(?:\?|$)",
        ]

        for pattern in patterns:
            match = re.search(pattern, question_lower)
            if match:
                langue_found = match.group(1).strip()
                # Nettoyer les articles
                langue_found = re.sub(r"^(le|la|les|du|de|des|en|une?)\s+", "", langue_found)
                return langue_found
        return None

    def _format_consultant_languages_response(self, consultant) -> str:
        """Formate la r√©ponse pour les langues d'un consultant"""
        if not consultant.langues:
            return f"‚ùå Aucune langue enregistr√©e pour **{consultant.prenom} {consultant.nom}**."

        response = "üåç **Langues parl√©es par " + consultant.prenom + " " + consultant.nom + " :**\n\n"

        flag_emoji = {
            "FR": "üá´üá∑",
            "EN": "üá¨üáß",
            "ES": "üá™üá∏",
            "DE": "üá©üá™",
            "IT": "üáÆüáπ",
            "PT": "üáµüáπ",
            "NL": "üá≥üá±",
            "RU": "üá∑üá∫",
            "ZH": "üá®üá≥",
            "JA": "üáØüáµ",
            "AR": "üá∏üá¶",
            "HI": "üáÆÔøΩ",
        }

        for cl in consultant.langues:
            emoji = flag_emoji.get(cl.langue.code_iso, "üåç")
            response += f"  {emoji} **{cl.langue.nom}** - {cl.niveau_label}"
            if cl.commentaire:
                response += f" - {cl.commentaire}"
            response += "\n"

        response += f"\nüìä **Total : {len(consultant.langues)} langue(s)**"
        return response

    def _handle_specific_language_search(self, langue_recherchee: str) -> Dict[str, Any]:
        """G√®re la recherche de consultants parlant une langue sp√©cifique"""
        consultants = self._find_consultants_by_language(langue_recherchee)

        if not consultants:
            return self._format_no_language_speakers_response(langue_recherchee)

        response = self._format_language_speakers_response(consultants, langue_recherchee)

        return {
            "response": response,
            "data": {"consultants": [{"nom": c.nom, "prenom": c.prenom} for c in consultants]},
            "intent": "langues",
            "confidence": 0.9,
        }

    def _format_no_language_speakers_response(self, langue_recherchee: str) -> Dict[str, Any]:
        """Formate la r√©ponse quand aucun consultant ne parle la langue"""
        return {
            "response": f"‚ùå Aucun consultant ne parle **{langue_recherchee}** dans notre base.",
            "data": {"consultants": []},
            "intent": "langues",
            "confidence": 0.8,
        }

    def _format_language_speakers_response(self, consultants: List, langue_recherchee: str) -> str:
        """Formate la r√©ponse compl√®te des consultants parlant une langue"""
        response = self._format_language_speakers_list(consultants, langue_recherchee)

        if len(consultants) <= 5:
            response += self._format_language_levels_details(consultants, langue_recherchee)

        return response

    def _format_language_speakers_list(self, consultants: List, langue_recherchee: str) -> str:
        """Formate la liste de base des consultants parlant une langue"""
        noms = [f"**{c.prenom} {c.nom}**" for c in consultants]
        response = f"üåç Consultants parlant **{langue_recherchee.title()}** :\n\n"
        response += "\n".join([f"‚Ä¢ {nom}" for nom in noms])
        response += f"\n\nüìä **{len(consultants)} consultant(s) trouv√©(s)**"
        return response

    def _format_language_levels_details(self, consultants: List, langue_recherchee: str) -> str:
        """Formate les d√©tails de niveaux pour une langue sp√©cifique"""
        details = "\n\nüéØ **Niveaux d√©taill√©s :**"

        for consultant in consultants:
            level_info = self._get_consultant_language_level(consultant, langue_recherchee)
            if level_info:
                details += f"\n  ‚Ä¢ **{consultant.prenom} {consultant.nom}** : {level_info['niveau']}"
                if level_info["commentaire"]:
                    details += f" - {level_info['commentaire']}"

        return details

    def _get_consultant_language_level(self, consultant, langue_recherchee: str) -> Optional[Dict[str, str]]:
        """R√©cup√®re le niveau et commentaire d'un consultant pour une langue"""
        for cl in consultant.langues:
            if cl.langue.nom.lower() == langue_recherchee.lower():
                return {"niveau": cl.niveau_label, "commentaire": cl.commentaire}
        return None

    def _handle_consultant_languages_inquiry(self, entities: Dict) -> Dict[str, Any]:
        """G√®re les questions sur les langues d'un consultant sp√©cifique"""
        question_lower = self.last_question.lower()

        # Si pas de nom d√©tect√© dans entities, essayer d'extraire manuellement
        nom = (
            entities["noms"][0]
            if entities["noms"]
            else self._extract_consultant_name_from_language_question(question_lower)
        )

        if nom:
            consultant = self._find_consultant_by_name(nom)

            if consultant:
                response = self._format_consultant_languages_response(consultant)
                return {
                    "response": response,
                    "data": {
                        "consultant": consultant.nom,
                        "languages_count": (len(consultant.langues) if consultant.langues else 0),
                    },
                    "intent": "langues",
                    "confidence": 0.8,
                }
            else:
                return {
                    "response": f"‚ùå Consultant **{nom}** introuvable.",
                    "data": {"consultant": None, "languages_count": 0},
                    "intent": "langues",
                    "confidence": 0.8,
                }
        else:
            # Question g√©n√©rale sur les langues sans nom sp√©cifique
            return {
                "response": 'üåç Pour conna√Ætre les langues d\'un consultant, demandez : "Quelles langues parle [nom] ?"\n\nOu pour trouver qui parle une langue : "Qui parle anglais ?"',
                "data": {},
                "intent": "langues",
                "confidence": 0.6,
            }

    def _handle_languages_question(self, entities: Dict) -> Dict[str, Any]:
        """G√®re les questions sur les langues parl√©es par les consultants"""

        # Si une langue sp√©cifique est mentionn√©e
        if entities["langues"]:
            return self._handle_specific_language_search(entities["langues"][0])

        # Question g√©n√©rale sur les langues d'un consultant
        elif entities["noms"] or any(
            word in self.last_question.lower() for word in ["quelles langues", "langues de", "langues parl√©es"]
        ):
            return self._handle_consultant_languages_inquiry(entities)

        # Recherche dynamique de langue dans la question
        elif any(word in self.last_question.lower() for word in ["qui parle", "parle", "parlent", "bilingue"]):
            question_lower = self.last_question.lower()
            langue_found = self._extract_language_from_question(question_lower)

            if langue_found:
                return self._handle_specific_language_search(langue_found)

        # Question g√©n√©rale sur les langues
        return {
            "response": 'üåç Pour conna√Ætre les langues d\'un consultant, demandez : "Quelles langues parle [nom] ?"\n\nOu pour trouver qui parle une langue : "Qui parle anglais ?"',
            "data": {},
            "intent": "langues",
            "confidence": 0.6,
        }

    def _handle_missions_question(self, entities: Dict) -> Dict[str, Any]:
        """G√®re les questions sur les missions"""
        question_lower: str = self.last_question.lower()
        is_count_question = self._is_count_question(question_lower)

        if entities["entreprises"]:
            return self._handle_company_missions_inquiry(entities["entreprises"][0], is_count_question)
        elif entities["noms"]:
            return self._handle_consultant_missions_inquiry(entities["noms"][0], is_count_question)
        else:
            return self._handle_generic_missions_question()

    def _is_count_question(self, question_lower: str) -> bool:
        """D√©termine si c'est une question de comptage"""
        return any(word in question_lower for word in ["combien", "nombre"])

    def _handle_company_missions_inquiry(self, entreprise: str, is_count_question: bool) -> Dict[str, Any]:
        """G√®re les questions sur les missions d'une entreprise"""
        missions = self._get_missions_by_company(entreprise)

        if is_count_question:
            response = self._format_company_missions_count(missions, entreprise)
        elif missions:
            response = self._format_company_missions_list(missions, entreprise)
        else:
            response = f"‚ùå Aucune mission trouv√©e chez **{entreprise}**."

        return {
            "response": response,
            "data": {"missions": len(missions), "entreprise": entreprise},
            "intent": "missions",
            "confidence": 0.9,
        }

    def _format_company_missions_count(self, missions: List, entreprise: str) -> str:
        """Formate le comptage des missions pour une entreprise"""
        return "üìä **" + str(len(missions)) + " mission(s)** trouv√©e(s) chez **" + entreprise.title() + "**"

    def _format_company_missions_list(self, missions: List, entreprise: str) -> str:
        """Formate la liste des missions pour une entreprise"""
        response = f"üè¢ **Missions chez {entreprise.title()} :**\n\n"

        for mission in missions[:5]:  # Limiter √† 5 r√©sultats
            consultant_nom = f"{mission.consultant.prenom} {mission.consultant.nom}"
            response += f"‚Ä¢ **{consultant_nom}** - {mission.nom_mission} ({mission.date_debut.strftime('%Y')})\n"

        if len(missions) > 5:
            response += f"\n... et {len(missions) - 5} autres missions"

        response += "\n\nüìä **Total : " + str(len(missions)) + " mission(s)**"
        return response

    def _handle_consultant_missions_inquiry(self, nom: str, is_count_question: bool) -> Dict[str, Any]:
        """G√®re les questions sur les missions d'un consultant"""
        consultant = self._find_consultant_by_name(nom)

        if not consultant:
            return self._format_consultant_not_found_missions_response(nom)

        missions = self._get_missions_by_consultant(consultant.id)

        if is_count_question:
            response = self._format_consultant_missions_count(consultant, missions)
        elif missions:
            response = self._format_consultant_missions_list(consultant, missions)
        else:
            response = f"‚ùå Aucune mission trouv√©e pour **{consultant.prenom} {consultant.nom}**."

        return {
            "response": response,
            "data": {
                "consultant": nom,
                "missions_count": len(missions),
            },
            "intent": "missions",
            "confidence": 0.9,
        }

    def _format_consultant_not_found_missions_response(self, nom: str) -> Dict[str, Any]:
        """Formate la r√©ponse quand le consultant n'est pas trouv√©"""
        return {
            "response": f"‚ùå Consultant **{nom}** introuvable.",
            "data": {
                "consultant": nom,
                "missions_count": 0,
            },
            "intent": "missions",
            "confidence": 0.9,
        }

    def _format_consultant_missions_count(self, consultant, missions: List) -> str:
        """Formate le comptage des missions pour un consultant"""
        response = (
            "üìä **"
            + consultant.prenom
            + " "
            + consultant.nom
            + "** a **"
            + str(len(missions))
            + " mission(s)** dans la base"
        )

        if missions:
            missions_en_cours = [m for m in missions if m.statut == "en_cours"]
            if missions_en_cours:
                response += " (dont " + str(len(missions_en_cours)) + " en cours)"

        return response

    def _format_consultant_missions_list(self, consultant, missions: List) -> str:
        """Formate la liste d√©taill√©e des missions pour un consultant"""
        response = f"üíº **Missions de {consultant.prenom} {consultant.nom} :**\n\n"

        for mission in missions:
            response += self._format_mission_details(mission)

        response += "üìä **Total : " + str(len(missions)) + " mission(s)**"
        return response

    def _format_mission_details(self, mission) -> str:
        """Formate les d√©tails d'une mission"""
        status_icon = "üü¢" if mission.statut == "en_cours" else "‚úÖ"
        details = f"{status_icon} **{mission.client}** - {mission.nom_mission}\n"
        details += f"   üìÖ {mission.date_debut.strftime('%m/%Y')} ‚Üí "

        if mission.date_fin:
            details += f"{mission.date_fin.strftime('%m/%Y')}"
        else:
            details += "En cours"

        if mission.taux_journalier:
            details += " | üí∞ " + str(mission.taux_journalier) + "‚Ç¨/jour"

        details += "\n\n"
        return details

    def _handle_generic_missions_question(self) -> Dict[str, Any]:
        """G√®re les questions g√©n√©riques sur les missions"""
        return {
            "response": "ü§î Voulez-vous conna√Ætre les missions d'un consultant ou d'une entreprise sp√©cifique ?",
            "data": None,
            "intent": "missions",
            "confidence": 0.5,
        }

    def _handle_stats_question(self) -> Dict[str, Any]:
        """G√®re les questions statistiques"""

        stats = self._get_general_stats()

        # Si c'est une question sp√©cifique sur le nombre de consultants
        if any(pattern in self.last_question for pattern in ["combien", "nombre"]):
            if "consultant" in self.last_question and "mission" not in self.last_question:
                response = f"üë• **Vous avez {stats['consultants_total']} consultants** dans votre base de donn√©es.\n\n"
                response += (
                    "üìä D√©tail : "
                    + str(stats["consultants_actifs"])
                    + " disponibles, "
                    + str(stats["consultants_inactifs"])
                    + " indisponibles"
                )

                return {
                    "response": response,
                    "data": {"consultants_count": stats["consultants_total"]},
                    "intent": "statistiques",
                    "confidence": 0.95,
                }

        # Statistiques compl√®tes par d√©faut
        response = f"""üìä **Statistiques g√©n√©rales :**

üë• **Consultants :**
‚Ä¢ Total : **{stats['consultants_total']}**
‚Ä¢ Actifs : **{stats['consultants_actifs']}**
‚Ä¢ Inactifs : **{stats['consultants_inactifs']}**

üè¢ **Practices :**
‚Ä¢ Total : **{stats['practices_total']}**

üíº **Missions :**
‚Ä¢ Total : **{stats['missions_total']}**
‚Ä¢ En cours : **{stats['missions_en_cours']}**
‚Ä¢ Termin√©es : **{stats['missions_terminees']}**

ÔøΩ **Documents :**
‚Ä¢ Total CVs : **{stats['cvs_total']}**
‚Ä¢ Consultants avec CV : **{stats['consultants_avec_cv']}**

ÔøΩüí∞ **Financier :**
‚Ä¢ TJM moyen : **{stats['tjm_moyen']:,.0f} ‚Ç¨**
‚Ä¢ Salaire moyen : **{stats['salaire_moyen']:,.0f} ‚Ç¨**
‚Ä¢ CJM moyen : **{stats['cjm_moyen']:,.0f} ‚Ç¨**"""

        return {
            "response": response,
            "data": {"stats": stats},
            "intent": "statistiques",
            "confidence": 0.9,
        }

    def _handle_contact_question(self, entities: Dict) -> Dict[str, Any]:
        """G√®re les questions sur les contacts (email, t√©l√©phone)"""

        if not entities["noms"]:
            return self._handle_generic_contact_question()

        nom: str = entities["noms"][0]
        consultant = self._find_consultant_by_name(nom)

        if not consultant:
            return self._handle_consultant_not_found_contact(nom)

        question_lower: str = self.last_question.lower()

        if self._is_email_question(question_lower):
            return self._handle_email_request(consultant)
        elif self._is_phone_question(question_lower):
            return self._handle_phone_request(consultant)
        else:
            return self._handle_complete_contact_request(consultant)

    def _handle_generic_contact_question(self) -> Dict[str, Any]:
        """G√®re les questions de contact g√©n√©riques sans nom sp√©cifique"""
        return {
            "response": "ü§î De quel consultant souhaitez-vous conna√Ætre les coordonn√©es ?",
            "data": None,
            "intent": "contact",
            "confidence": 0.5,
        }

    def _handle_consultant_not_found_contact(self, nom: str) -> Dict[str, Any]:
        """G√®re le cas o√π le consultant n'est pas trouv√© pour une question de contact"""
        return {
            "response": f"‚ùå Je n'ai pas trouv√© de consultant nomm√© **{nom}** dans la base de donn√©es.",
            "data": None,
            "intent": "contact",
            "confidence": 0.7,
        }

    def _is_email_question(self, question_lower: str) -> bool:
        """D√©termine si la question concerne l'email"""
        return any(word in question_lower for word in ["mail", "email", "e-mail"])

    def _is_phone_question(self, question_lower: str) -> bool:
        """D√©termine si la question concerne le t√©l√©phone"""
        return any(word in question_lower for word in ["t√©l√©phone", "tel", "num√©ro"])

    def _handle_email_request(self, consultant) -> Dict[str, Any]:
        """G√®re les demandes sp√©cifiques d'email"""
        if consultant.email:
            response = f"ÔøΩ L'email de **{consultant.prenom} {consultant.nom}** est : **{consultant.email}**"
        else:
            response = (
                f"‚ùì D√©sol√©, l'email de **{consultant.prenom} {consultant.nom}** n'est pas renseign√© dans la base."
            )

        return {
            "response": response,
            "data": {
                "consultant": consultant.nom,
                "email": consultant.email,
                "telephone": consultant.telephone,
            },
            "intent": "contact",
            "confidence": 0.9,
        }

    def _handle_phone_request(self, consultant) -> Dict[str, Any]:
        """G√®re les demandes sp√©cifiques de t√©l√©phone"""
        if consultant.telephone:
            response = f"üìû Le t√©l√©phone de **{consultant.prenom} {consultant.nom}** est : **{consultant.telephone}**"
        else:
            response = (
                f"‚ùì D√©sol√©, le t√©l√©phone de **{consultant.prenom} {consultant.nom}** n'est pas renseign√© dans la base."
            )

        return {
            "response": response,
            "data": {
                "consultant": consultant.nom,
                "email": consultant.email,
                "telephone": consultant.telephone,
            },
            "intent": "contact",
            "confidence": 0.9,
        }

    def _handle_complete_contact_request(self, consultant) -> Dict[str, Any]:
        """G√®re les demandes de contact complet"""
        response = f"üìû **Contact de {consultant.prenom} {consultant.nom} :**\n\n"
        response += f"üìß Email : **{consultant.email or 'Non renseign√©'}**\n"
        response += f"üìû T√©l√©phone : **{consultant.telephone or 'Non renseign√©'}**"

        return {
            "response": response,
            "data": {
                "consultant": consultant.nom,
                "email": consultant.email,
                "telephone": consultant.telephone,
            },
            "intent": "contact",
            "confidence": 0.9,
        }

    def _handle_list_consultants_question(self) -> Dict[str, Any]:
        """G√®re les questions pour lister les consultants selon des crit√®res"""
        question_lower: str = self.last_question.lower()

        consultants, titre = self._get_consultants_by_criteria(question_lower)

        if not consultants:
            return self._handle_no_consultants_found()

        response = self._format_consultants_list(consultants, titre)
        data = self._build_consultants_data(consultants)

        return {
            "response": response,
            "data": data,
            "intent": "liste_consultants",
            "confidence": 0.9,
        }

    def _get_consultants_by_criteria(self, question_lower: str) -> tuple:
        """R√©cup√®re les consultants selon les crit√®res de la question"""
        with get_database_session() as session:
            if "disponibles" in question_lower or "disponible" in question_lower:
                consultants = session.query(Consultant).filter(Consultant.disponibilite).all()
                titre = "üë• **Consultants disponibles :**"
            elif "indisponibles" in question_lower or "indisponible" in question_lower:
                consultants = session.query(Consultant).filter(Consultant.disponibilite is False).all()
                titre = "üë• **Consultants indisponibles :**"
            elif "actifs" in question_lower or "actif" in question_lower:
                consultants = session.query(Consultant).filter(Consultant.disponibilite).all()
                titre = "üë• **Consultants actifs :**"
            else:
                consultants = session.query(Consultant).all()
                titre = "üë• **Tous les consultants :**"

        return consultants, titre

    def _handle_no_consultants_found(self) -> Dict[str, Any]:
        """G√®re le cas o√π aucun consultant n'est trouv√©"""
        return {
            "response": "‚ùì Aucun consultant ne correspond √† ce crit√®re.",
            "data": None,
            "intent": "liste_consultants",
            "confidence": 0.8,
        }

    def _format_consultants_list(self, consultants: List, titre: str) -> str:
        """Formate la liste des consultants pour l'affichage"""
        response = f"{titre}\n\n"

        for i, consultant in enumerate(consultants, 1):
            response += self._format_consultant_line(consultant, i)

        response += "\nüìä **Total : " + str(len(consultants)) + " consultant(s)**"
        return response

    def _format_consultant_line(self, consultant, index: int) -> str:
        """Formate une ligne de consultant dans la liste"""
        status_icon = "üü¢" if consultant.disponibilite else "üî¥"
        line = f"{index}. {status_icon} **{consultant.prenom} {consultant.nom}**"

        if consultant.email:
            line += f" - {consultant.email}"

        if consultant.salaire_actuel:
            cjm = self._calculate_cjm(consultant.salaire_actuel)
            line += f" - {consultant.salaire_actuel:,.0f} ‚Ç¨/an - CJM: {cjm:,.0f} ‚Ç¨"

        line += "\n"
        return line

    def _calculate_cjm(self, salaire_actuel: float) -> float:
        """Calcule le CJM √† partir du salaire annuel"""
        return salaire_actuel * 1.8 / 216

    def _build_consultants_data(self, consultants: List) -> Dict:
        """Construit les donn√©es structur√©es des consultants"""
        return {
            "consultants": [
                {
                    "nom": c.nom,
                    "prenom": c.prenom,
                    "email": c.email,
                    "disponibilite": c.disponibilite,
                    "salaire": c.salaire_actuel,
                    "cjm": (self._calculate_cjm(c.salaire_actuel) if c.salaire_actuel else None),
                }
                for c in consultants
            ],
            "count": len(consultants),
        }

    def _handle_consultant_search(self, entities: Dict) -> Dict[str, Any]:
        """G√®re la recherche d'informations sur un consultant"""

        if not entities["noms"]:
            return self._handle_generic_consultant_search()

        nom: str = entities["noms"][0]
        consultant = self._find_consultant_by_name(nom)

        if not consultant:
            return self._handle_consultant_not_found_search(nom)

        response = self._build_consultant_profile_response(consultant)

        return {
            "response": response,
            "data": {"consultant": consultant.nom},
            "intent": "recherche_consultant",
            "confidence": 0.9,
        }

    def _handle_generic_consultant_search(self) -> Dict[str, Any]:
        """G√®re les recherches g√©n√©riques sans nom sp√©cifique"""
        return {
            "response": "ü§î De quel consultant souhaitez-vous conna√Ætre les informations ?",
            "data": None,
            "intent": "recherche_consultant",
            "confidence": 0.5,
        }

    def _handle_consultant_not_found_search(self, nom: str) -> Dict[str, Any]:
        """G√®re le cas o√π le consultant n'est pas trouv√©"""
        return {
            "response": f"‚ùå Consultant **{nom}** introuvable dans la base de donn√©es.",
            "data": {"consultant": None},
            "intent": "recherche_consultant",
            "confidence": 0.9,
        }

    def _build_consultant_profile_response(self, consultant) -> str:
        """Construit la r√©ponse compl√®te du profil consultant"""
        response = self._format_basic_consultant_info(consultant)
        response += self._format_consultant_salary_info(consultant)
        response += self._format_consultant_missions_info(consultant)
        return response

    def _format_basic_consultant_info(self, consultant) -> str:
        """Formate les informations de base du consultant"""
        date_creation = (
            consultant.date_creation.strftime(self.DATE_FORMAT) if consultant.date_creation else "Non renseign√©e"
        )

        return f"""üë§ **{consultant.prenom} {consultant.nom}**

üìß Email : {consultant.email or 'Non renseign√©'}
üìû T√©l√©phone : {consultant.telephone or 'Non renseign√©'}
üìä Disponibilit√© : **{'Disponible' if consultant.disponibilite else 'Indisponible'}**
üìÖ Date cr√©ation : {date_creation}"""

    def _format_consultant_salary_info(self, consultant) -> str:
        """Formate les informations salariales du consultant"""
        if not consultant.salaire_actuel:
            return ""

        cjm = self._calculate_cjm(consultant.salaire_actuel)
        return f"\nüí∞ Salaire : **{consultant.salaire_actuel:,.0f} ‚Ç¨**" + f"\nüìà CJM : **{cjm:,.0f} ‚Ç¨**"

    def _format_consultant_missions_info(self, consultant) -> str:
        """Formate les informations sur les missions du consultant"""
        missions_count = len(consultant.missions)
        if missions_count > 0:
            return f"\nüíº Missions : **{missions_count}** mission(s)"
        return ""

    def _handle_general_question(self) -> Dict[str, Any]:
        """G√®re les questions g√©n√©rales"""

        responses = [
            "ü§ñ Je suis l√† pour vous aider √† interroger la base de donn√©es des consultants !",
            "",
            "üí° **Voici quelques exemples de questions :**",
            "",
            'üí∞ *Salaires :* "Quel est le salaire de Jean Dupont ?"',
            'ÔøΩ *Exp√©rience :* "Quelle est l\'exp√©rience de Jean Dupont ?"',
            'üéØ *Grade :* "Quel est le grade de Marie ?"',
            'üìã *Contrat :* "Quel est le type de contrat de Paul ?"',
            'üè¢ *Soci√©t√© :* "Dans quelle soci√©t√© travaille Anne ?"',
            'ÔøΩüìß *Contact :* "Quel est l\'email de Marie ?"',
            'üë• *Listes :* "Quels sont les consultants disponibles ?"',
            'üîç *Comp√©tences :* "Qui ma√Ætrise Python ?"',
            'üíº *Missions :* "Quelles sont les missions chez BNP Paribas ?"',
            'ÔøΩ *Statistiques :* "Combien de consultants sont actifs ?"',
            'üë§ *Profils :* "Qui est Marie Martin ?"',
            "",
            "Que souhaitez-vous savoir ? üòä",
        ]

        return {
            "response": "\n".join(responses),
            "data": None,
            "intent": "general",
            "confidence": 1.0,
        }

    def _handle_practices_question(self, entities: Dict) -> Dict[str, Any]:
        """
        G√®re les questions sur les practices (√©quipes) des consultants.
        """
        from database.models import Practice

        if entities["practices"]:
            return self._handle_specific_practice_question(entities["practices"][0])
        else:
            return self._handle_general_practices_question()

    def _handle_specific_practice_question(self, practice_name: str) -> Dict[str, Any]:
        """G√®re les questions sur une practice sp√©cifique"""
        from database.models import Practice

        with get_database_session() as session:
            practice = (
                session.query(Practice)
                .options(joinedload(Practice.consultants))
                .filter(func.lower(Practice.nom) == practice_name.lower())
                .first()
            )

        if not practice:
            return self._handle_practice_not_found(practice_name)

        consultants = list(practice.consultants)

        if not consultants:
            return self._handle_empty_practice(practice)

        response = self._format_practice_consultants_response(practice, consultants)
        data = self._build_practice_consultants_data(practice, consultants)

        return {
            "response": response,
            "data": data,
            "intent": "practices",
            "confidence": 0.9,
        }

    def _handle_practice_not_found(self, practice_name: str) -> Dict[str, Any]:
        """G√®re le cas o√π la practice n'est pas trouv√©e"""
        return {
            "response": f"‚ùå Practice **{practice_name}** introuvable dans la base.",
            "data": None,
            "intent": "practices",
            "confidence": 0.7,
        }

    def _handle_empty_practice(self, practice) -> Dict[str, Any]:
        """G√®re le cas o√π la practice n'a aucun consultant"""
        return {
            "response": f"üìã **Practice {practice.nom}** : Aucun consultant assign√©",
            "data": {
                "practice": practice.nom,
                "consultants": [],
            },
            "intent": "practices",
            "confidence": 0.9,
        }

    def _format_practice_consultants_response(self, practice, consultants: List) -> str:
        """Formate la r√©ponse pour les consultants d'une practice"""
        response = f"üë• **Practice {practice.nom}** :\n\n"
        response += f"üìã **{len(consultants)} consultant(s)** :\n"

        for i, consultant in enumerate(consultants, 1):
            response += self._format_practice_consultant_line(consultant, i)

        if practice.responsable:
            response += f"\nüë®‚Äçüíº **Responsable** : {practice.responsable}"

        return response

    def _format_practice_consultant_line(self, consultant, index: int) -> str:
        """Formate une ligne de consultant dans une practice"""
        status_icon = "üü¢" if consultant.disponibilite else "üî¥"
        line = f"{index}. {status_icon} **{consultant.prenom} {consultant.nom}**"

        if consultant.salaire_actuel:
            cjm = self._calculate_cjm(consultant.salaire_actuel)
            line += f" - CJM: {cjm:,.0f} ‚Ç¨"

        line += "\n"
        return line

    def _build_practice_consultants_data(self, practice, consultants: List) -> Dict:
        """Construit les donn√©es structur√©es d'une practice"""
        return {
            "practice": practice.nom,
            "consultants": [
                {
                    "nom": c.nom,
                    "prenom": c.prenom,
                    "disponibilite": c.disponibilite,
                    "cjm": (self._calculate_cjm(c.salaire_actuel) if c.salaire_actuel else None),
                }
                for c in consultants
            ],
        }

    def _handle_general_practices_question(self) -> Dict[str, Any]:
        """G√®re les questions g√©n√©rales sur toutes les practices"""
        from database.models import Practice

        with get_database_session() as session:
            practices = session.query(Practice).filter(Practice.actif).all()

        if not practices:
            return self._handle_no_practices_found()

        response = self._format_all_practices_response(practices)
        data = self._build_all_practices_data(practices)

        return {
            "response": response,
            "data": data,
            "intent": "practices",
            "confidence": 0.8,
        }

    def _handle_no_practices_found(self) -> Dict[str, Any]:
        """G√®re le cas o√π aucune practice active n'est trouv√©e"""
        return {
            "response": "‚ùì Aucune practice active trouv√©e dans la base.",
            "data": None,
            "intent": "practices",
            "confidence": 0.6,
        }

    def _format_all_practices_response(self, practices: List) -> str:
        """Formate la r√©ponse pour toutes les practices"""
        response = "üè¢ **Practices disponibles** :\n\n"

        for practice in practices:
            response += self._format_practice_summary_line(practice)

        return response

    def _format_practice_summary_line(self, practice) -> str:
        """Formate une ligne de r√©sum√© pour une practice"""
        nb_consultants = len(list(practice.consultants))
        nb_disponibles = len([c for c in practice.consultants if c.disponibilite])

        line = f"‚Ä¢ **{practice.nom}** : {nb_consultants} consultant(s) ({nb_disponibles} disponible(s))\n"

        if practice.responsable:
            line += f"  üë®‚Äçüíº Responsable : {practice.responsable}\n"

        return line

    def _build_all_practices_data(self, practices: List) -> Dict:
        """Construit les donn√©es structur√©es de toutes les practices"""
        return {
            "practices": [
                {
                    "nom": p.nom,
                    "consultants_total": len(list(p.consultants)),
                    "consultants_disponibles": len([c for c in p.consultants if c.disponibilite]),
                    "responsable": p.responsable,
                }
                for p in practices
            ]
        }

    def _handle_cvs_question(self, entities: Dict) -> Dict[str, Any]:
        """G√®re les questions sur les CVs des consultants."""

        if entities["noms"]:
            return self._handle_specific_consultant_cvs(entities["noms"][0])
        else:
            return self._handle_general_cvs_question()

    def _handle_specific_consultant_cvs(self, nom_recherche: str) -> Dict[str, Any]:
        """G√®re les questions sur les CVs d'un consultant sp√©cifique"""
        consultant = self._find_consultant_by_name(nom_recherche)

        if not consultant:
            return self._handle_consultant_not_found_cvs(nom_recherche)

        cvs = consultant.cvs

        if not cvs:
            return self._handle_no_cvs_found(consultant)

        response = self._format_consultant_cvs_response(consultant, cvs)
        data = self._build_consultant_cvs_data(consultant, cvs)

        return {
            "response": response,
            "data": data,
            "intent": "cvs",
            "confidence": 0.9,
        }

    def _handle_consultant_not_found_cvs(self, nom_recherche: str) -> Dict[str, Any]:
        """G√®re le cas o√π le consultant n'est pas trouv√© pour les CVs"""
        return {
            "response": f"‚ùå Consultant **{nom_recherche}** introuvable.",
            "data": None,
            "intent": "cvs",
            "confidence": 0.7,
        }

    def _handle_no_cvs_found(self, consultant) -> Dict[str, Any]:
        """G√®re le cas o√π le consultant n'a aucun CV"""
        response = f"üìÅ **{consultant.prenom} {consultant.nom}** : Aucun CV upload√©"

        return {
            "response": response,
            "data": {
                "consultant": f"{consultant.prenom} {consultant.nom}",
                "cvs": [],
            },
            "intent": "cvs",
            "confidence": 0.9,
        }

    def _format_consultant_cvs_response(self, consultant, cvs: List) -> str:
        """Formate la r√©ponse des CVs d'un consultant"""
        response = f"üìÅ **CVs de {consultant.prenom} {consultant.nom}{self.SECTION_HEADER_SUFFIX}"

        for i, cv in enumerate(cvs, 1):
            response += self._format_cv_details(cv, i)

        response += f"üìä **Total : {len(cvs)} document(s)**"
        return response

    def _format_cv_details(self, cv, index: int) -> str:
        """Formate les d√©tails d'un CV"""
        taille_mb = (cv.taille_fichier / 1024 / 1024) if cv.taille_fichier else 0
        date_upload = cv.date_upload.strftime(self.DATE_FORMAT) if cv.date_upload else "N/A"

        details = f"{index}. **{cv.fichier_nom}**\n"
        details += f"   üìÖ Upload√© le : {date_upload}\n"
        details += f"   üìè Taille : {taille_mb:.1f} MB\n"

        if cv.contenu_extrait:
            details += "   ‚úÖ Contenu analys√©\n"

        details += "\n"
        return details

    def _build_consultant_cvs_data(self, consultant, cvs: List) -> Dict:
        """Construit les donn√©es structur√©es des CVs d'un consultant"""
        return {
            "consultant": f"{consultant.prenom} {consultant.nom}",
            "cvs": [
                {
                    "nom": cv.fichier_nom,
                    "date_upload": (cv.date_upload.isoformat() if cv.date_upload else None),
                    "taille": cv.taille_fichier,
                    "contenu_analyse": bool(cv.contenu_extrait),
                }
                for cv in cvs
            ],
        }

    def _handle_general_cvs_question(self) -> Dict[str, Any]:
        """G√®re les questions g√©n√©rales sur les CVs"""
        from database.models import CV

        stats = self._get_cvs_statistics()
        top_consultants = self._get_top_consultants_by_cvs()

        response = self._format_general_cvs_response(stats, top_consultants)
        data = self._build_general_cvs_data(stats, top_consultants)

        return {
            "response": response,
            "data": data,
            "intent": "cvs",
            "confidence": 0.8,
        }

    def _get_cvs_statistics(self) -> Dict:
        """R√©cup√®re les statistiques g√©n√©rales des CVs"""
        from database.models import CV

        with get_database_session() as session:
            cvs_total = session.query(CV).count()
            consultants_avec_cv = session.query(Consultant).join(CV).distinct().count()

        return {"cvs_total": cvs_total, "consultants_avec_cv": consultants_avec_cv}

    def _get_top_consultants_by_cvs(self) -> List:
        """R√©cup√®re le top 3 des consultants avec le plus de CVs"""
        from sqlalchemy import func

        from database.models import CV

        with get_database_session() as session:
            return (
                session.query(Consultant, func.count(CV.id).label("nb_cvs"))
                .join(CV)
                .group_by(Consultant.id)
                .order_by(func.count(CV.id).desc())
                .limit(3)
                .all()
            )

    def _format_general_cvs_response(self, stats: Dict, top_consultants: List) -> str:
        """Formate la r√©ponse g√©n√©rale sur les CVs"""
        response = "üìÅ **Statistiques des CVs** :\n\n"
        response += f"‚Ä¢ Total de documents : **{stats['cvs_total']}**\n"
        response += f"‚Ä¢ Consultants avec CV : **{stats['consultants_avec_cv']}**\n"

        if top_consultants:
            response += "\nüèÜ **Top consultants (nombre de CVs)** :\n"
            for consultant, nb_cvs in top_consultants:
                response += f"‚Ä¢ **{consultant.prenom} {consultant.nom}** : {nb_cvs} CV(s)\n"

        return response

    def _build_general_cvs_data(self, stats: Dict, top_consultants: List) -> Dict:
        """Construit les donn√©es structur√©es g√©n√©rales des CVs"""
        return {
            "cvs_total": stats["cvs_total"],
            "consultants_avec_cv": stats["consultants_avec_cv"],
            "top_consultants": [{"nom": c.nom, "prenom": c.prenom, "nb_cvs": nb} for c, nb in top_consultants],
        }

    # M√©thodes utilitaires pour les requ√™tes DB

    def _find_consultant_by_name(self, nom_recherche: str) -> Optional[Consultant]:
        """
        Recherche flexible d'un consultant par son nom.

        Effectue d'abord une recherche exacte sur pr√©nom, nom ou nom complet,
        puis une recherche partielle si aucune correspondance exacte n'est trouv√©e.

        Args:
            nom_recherche: Nom ou pr√©nom du consultant √† rechercher (insensible √† la casse)

        Returns:
            Objet Consultant si trouv√©, None sinon

        Raises:
            SQLAlchemyError: En cas d'erreur de base de donn√©es

        Example:
            >>> consultant = chatbot._find_consultant_by_name("Jean Dupont")
            >>> print(consultant.prenom, consultant.nom)
            Jean Dupont

            >>> consultant = chatbot._find_consultant_by_name("Dupont")
            >>> print(consultant.prenom, consultant.nom)
            Jean Dupont
        """

        # Essayer une correspondance exacte d'abord
        with get_database_session() as session:

            consultant = (
                session.query(Consultant)
                .options(joinedload(Consultant.langues).joinedload(ConsultantLangue.langue))
                .filter(
                    or_(
                        func.lower(Consultant.nom) == nom_recherche.lower(),
                        func.lower(Consultant.prenom) == nom_recherche.lower(),
                        func.lower(func.concat(Consultant.prenom, " ", Consultant.nom)) == nom_recherche.lower(),
                        func.lower(func.concat(Consultant.nom, " ", Consultant.prenom)) == nom_recherche.lower(),
                    )
                )
                .first()
            )

        if consultant:
            return consultant

        # Essayer une correspondance partielle
        with get_database_session() as session:

            consultant = (
                session.query(Consultant)
                .options(joinedload(Consultant.langues).joinedload(ConsultantLangue.langue))
                .filter(
                    or_(
                        func.lower(Consultant.nom).like(f"%{nom_recherche.lower()}%"),
                        func.lower(Consultant.prenom).like(f"%{nom_recherche.lower()}%"),
                    )
                )
                .first()
            )

        return consultant

    def _find_consultants_by_skill(self, competence: str, type_competence: Optional[str] = None) -> List[Any]:
        """
        Recherche les consultants ma√Ætrisant une comp√©tence sp√©cifique.

        Args:
            competence: Nom de la comp√©tence √† rechercher (insensible √† la casse)
            type_competence: Type de comp√©tence (technique/fonctionnelle) pour filtrer (optionnel)

        Returns:
            Liste des objets Consultant ma√Ætrisant la comp√©tence

        Raises:
            SQLAlchemyError: En cas d'erreur de base de donn√©es

        Example:
            >>> consultants = chatbot._find_consultants_by_skill("Python", "technique")
            >>> print(f"Trouv√© {len(consultants)} consultants Python")

            >>> consultants = chatbot._find_consultants_by_skill("SQL")
            >>> print(f"Trouv√© {len(consultants)} consultants SQL")
        """
        from database.models import Competence
        from database.models import ConsultantCompetence

        # Construction de la requ√™te de base
        with get_database_session() as session:

            query = (
                session.query(Consultant)
                .join(
                    ConsultantCompetence,
                    Consultant.id == ConsultantCompetence.consultant_id,
                )
                .join(Competence, ConsultantCompetence.competence_id == Competence.id)
                .filter(func.lower(Competence.nom).like(f"%{competence.lower()}%"))
            )

        # Ajouter le filtre par type si sp√©cifi√©
        if type_competence:
            query = query.filter(Competence.type_competence == type_competence)

        consultants = query.distinct().all()

        return consultants  # type: ignore[no-any-return]

    def _find_consultants_by_language(self, langue: str) -> List[Any]:
        """
        Recherche les consultants parlant une langue sp√©cifique.

        Args:
            langue: Nom de la langue √† rechercher (insensible √† la casse)

        Returns:
            Liste des objets Consultant parlant la langue

        Raises:
            SQLAlchemyError: En cas d'erreur de base de donn√©es

        Example:
            >>> consultants = chatbot._find_consultants_by_language("anglais")
            >>> print(f"Trouv√© {len(consultants)} consultants anglophones")

            >>> consultants = chatbot._find_consultants_by_language("espagnol")
            >>> print(f"Trouv√© {len(consultants)} consultants hispanophones")
        """

        # Construction de la requ√™te de base
        with get_database_session() as session:

            consultants = (
                session.query(Consultant)
                .join(ConsultantLangue, Consultant.id == ConsultantLangue.consultant_id)
                .join(Langue, ConsultantLangue.langue_id == Langue.id)
                .filter(func.lower(Langue.nom).like(f"%{langue.lower()}%"))
                .distinct()
                .all()
            )

        return consultants  # type: ignore[no-any-return]

    def _get_missions_by_company(self, entreprise: str) -> List[Mission]:
        """
        R√©cup√®re toutes les missions associ√©es √† une entreprise.

        Args:
            entreprise: Nom de l'entreprise √† rechercher (insensible √† la casse)

        Returns:
            Liste des objets Mission pour cette entreprise

        Raises:
            SQLAlchemyError: En cas d'erreur de base de donn√©es

        Example:
            >>> missions = chatbot._get_missions_by_company("BNP Paribas")
            >>> print(f"BNP Paribas a {len(missions)} missions")
        """
        with get_database_session() as session:
            return (
                session.query(Mission)
                .filter(func.lower(Mission.client).like(f"%{entreprise.lower()}%"))  # type: ignore[no-any-return]
                .all()
            )

    def _get_missions_by_consultant(self, consultant_id: int) -> List[Mission]:
        """
        R√©cup√®re toutes les missions d'un consultant sp√©cifique.

        Args:
            consultant_id: Identifiant unique du consultant

        Returns:
            Liste des objets Mission du consultant, tri√©s par date de d√©but d√©croissante

        Raises:
            SQLAlchemyError: En cas d'erreur de base de donn√©es

        Example:
            >>> missions = chatbot._get_missions_by_consultant(123)
            >>> print(f"Consultant 123 a {len(missions)} missions")
            >>> if missions:
            ...     print(f"Derni√®re mission: {missions[0].nom_mission}")
        """
        with get_database_session() as session:
            return (
                session.query(Mission)
                .filter(Mission.consultant_id == consultant_id)  # type: ignore[no-any-return]
                .order_by(Mission.date_debut.desc())
                .all()
            )

    def _get_consultant_skills(self, consultant_id: int, type_competence: Optional[str] = None) -> List[Dict[str, Any]]:
        """
        R√©cup√®re les comp√©tences d√©taill√©es d'un consultant.

        Args:
            consultant_id: Identifiant unique du consultant
            type_competence: Type de comp√©tence √† filtrer (technique/fonctionnelle) (optionnel)

        Returns:
            Liste de dictionnaires contenant les d√©tails des comp√©tences :
            - nom: Nom de la comp√©tence
            - categorie: Cat√©gorie de la comp√©tence
            - type: Type de comp√©tence (technique/fonctionnelle)
            - niveau_maitrise: Niveau de ma√Ætrise (d√©butant/interm√©diaire/expert)
            - annees_experience: Nombre d'ann√©es d'exp√©rience
            - description: Description de la comp√©tence

        Raises:
            SQLAlchemyError: En cas d'erreur de base de donn√©es

        Example:
            >>> skills = chatbot._get_consultant_skills(123, "technique")
            >>> print(f"Consultant 123 a {len(skills)} comp√©tences techniques")
            >>> for skill in skills:
            ...     print(f"- {skill['nom']}: {skill['niveau_maitrise']}")
        """
        with get_database_session() as session:

            query = (
                session.query(ConsultantCompetence)
                .join(Competence)
                .filter(ConsultantCompetence.consultant_id == consultant_id)
            )

        # Ajouter le filtre par type si sp√©cifi√©
        if type_competence:
            query = query.filter(Competence.type_competence == type_competence)

        consultant_competences = query.all()

        skills = []
        for cc in consultant_competences:
            skills.append(
                {
                    "nom": cc.competence.nom,
                    "categorie": cc.competence.categorie,
                    "type": cc.competence.type_competence,
                    "niveau_maitrise": cc.niveau_maitrise,
                    "annees_experience": cc.annees_experience,
                    "description": cc.competence.description,
                }
            )

        return skills

    def _get_salary_stats(self) -> Dict[str, float]:
        """
        Calcule les statistiques des salaires des consultants.

        Returns:
            Dictionnaire contenant :
            - moyenne: Salaire moyen
            - mediane: Salaire m√©dian
            - minimum: Salaire minimum
            - maximum: Salaire maximum
            - total: Nombre de consultants avec salaire renseign√©

        Raises:
            SQLAlchemyError: En cas d'erreur de base de donn√©es

        Example:
            >>> stats = chatbot._get_salary_stats()
            >>> print(f"Salaire moyen: {stats['moyenne']:,.0f} ‚Ç¨")
            >>> print(f"Salaire m√©dian: {stats['mediane']:,.0f} ‚Ç¨")
        """
        with get_database_session() as session:

            consultants = (
                session.query(Consultant)
                .filter(
                    and_(
                        Consultant.salaire_actuel.isnot(None),
                        Consultant.salaire_actuel > 0,
                    )
                )
                .all()
            )

        if not consultants:
            return {"moyenne": 0, "mediane": 0, "minimum": 0, "maximum": 0, "total": 0}

        salaires = [c.salaire_actuel for c in consultants]
        salaires.sort()

        return {
            "moyenne": sum(salaires) / len(salaires),
            "mediane": salaires[len(salaires) // 2],
            "minimum": min(salaires),
            "maximum": max(salaires),
            "total": len(consultants),
        }

    def _get_general_stats(self) -> Dict[str, Any]:
        """
        Calcule les statistiques g√©n√©rales de la base de donn√©es.
        """
        with get_database_session() as session:
            consultant_stats = self._get_consultant_statistics(session)
            mission_stats = self._get_mission_statistics(session)
            practice_stats = self._get_practice_statistics(session)
            cv_stats = self._get_cv_statistics(session)
            financial_stats = self._get_financial_statistics(session)

        return {
            **consultant_stats,
            **mission_stats,
            **practice_stats,
            **cv_stats,
            **financial_stats,
        }

    def _get_consultant_statistics(self, session) -> Dict[str, int]:
        """R√©cup√®re les statistiques des consultants"""
        consultants_total = session.query(Consultant).count()
        consultants_actifs = session.query(Consultant).filter(Consultant.disponibilite).count()
        consultants_inactifs = consultants_total - consultants_actifs

        return {
            "consultants_total": consultants_total,
            "consultants_actifs": consultants_actifs,
            "consultants_inactifs": consultants_inactifs,
        }

    def _get_mission_statistics(self, session) -> Dict[str, int]:
        """R√©cup√®re les statistiques des missions"""
        missions_total = session.query(Mission).count()
        missions_en_cours = session.query(Mission).filter(Mission.statut == "en_cours").count()
        missions_terminees = missions_total - missions_en_cours

        return {
            "missions_total": missions_total,
            "missions_en_cours": missions_en_cours,
            "missions_terminees": missions_terminees,
        }

    def _get_practice_statistics(self, session) -> Dict[str, int]:
        """R√©cup√®re les statistiques des practices"""
        from database.models import Practice

        practices_total = session.query(Practice).filter(Practice.actif).count()

        return {
            "practices_total": practices_total,
        }

    def _get_cv_statistics(self, session) -> Dict[str, int]:
        """R√©cup√®re les statistiques des CVs"""
        from database.models import CV

        cvs_total = session.query(CV).count()
        consultants_avec_cv = session.query(Consultant).join(CV).distinct().count()

        return {
            "cvs_total": cvs_total,
            "consultants_avec_cv": consultants_avec_cv,
        }

    def _get_financial_statistics(self, session) -> Dict[str, float]:
        """R√©cup√®re les statistiques financi√®res"""
        tjm_moyen = self._calculate_average_tjm(session)
        salaire_moyen = self._calculate_average_salary(session)
        cjm_moyen = self._calculate_average_cjm(salaire_moyen)

        return {
            "tjm_moyen": tjm_moyen,
            "salaire_moyen": salaire_moyen,
            "cjm_moyen": cjm_moyen,
        }

    def _calculate_average_tjm(self, session) -> float:
        """Calcule le TJM moyen"""
        return (
            session.query(func.avg(Mission.taux_journalier)).filter(Mission.taux_journalier.isnot(None)).scalar() or 0
        )

    def _calculate_average_salary(self, session) -> float:
        """Calcule le salaire moyen"""
        return (
            session.query(func.avg(Consultant.salaire_actuel)).filter(Consultant.salaire_actuel.isnot(None)).scalar()
            or 0
        )

    def _calculate_average_cjm(self, salaire_moyen: float) -> float:
        """Calcule le CJM moyen √† partir du salaire moyen"""
        return (salaire_moyen * 1.8 / 216) if salaire_moyen > 0 else 0

    def _handle_availability_question(self, entities: Dict) -> Dict[str, Any]:
        """
        G√®re les questions sur la disponibilit√© des consultants (V1.2.2).

        Args:
            entities: Dictionnaire contenant les entit√©s extraites

        Returns:
            Dictionnaire avec la r√©ponse format√©e
        """
        consultant = self._get_consultant_from_entities(entities)

        if consultant:
            return self._handle_specific_consultant_availability(consultant)
        else:
            return self._handle_general_availability_question()

    def _get_consultant_from_entities(self, entities: Dict):
        """Extrait le consultant depuis les entit√©s"""
        if entities["noms"]:
            nom_complet = " ".join(entities["noms"])
            return self._find_consultant_by_name(nom_complet)
        return None

    def _handle_specific_consultant_availability(self, consultant) -> Dict[str, Any]:
        """G√®re la disponibilit√© d'un consultant sp√©cifique"""
        try:
            consultant_db = self._get_consultant_db_data(consultant)

            if consultant_db:
                response = self._build_availability_response(consultant, consultant_db)
            else:
                response = self._format_availability_error(consultant)

            return self._build_availability_result(consultant, consultant_db, response)

        except (SQLAlchemyError, AttributeError, ValueError, TypeError) as e:
            return self._build_availability_error_result(e)

    def _get_consultant_db_data(self, consultant):
        """R√©cup√®re les donn√©es DB du consultant"""
        with get_database_session() as session:
            return session.query(Consultant).filter(Consultant.id == consultant.id).first()

    def _build_availability_response(self, consultant, consultant_db) -> str:
        """Construit la r√©ponse de disponibilit√©"""
        response = self._format_availability_header(consultant)
        response += self._format_availability_status(consultant_db)
        response += self._format_consultant_details(consultant_db)
        return response

    def _format_availability_header(self, consultant) -> str:
        """Formate l'en-t√™te de disponibilit√©"""
        return "üìÖ **Disponibilit√© de " + consultant.prenom + " " + consultant.nom + self.SECTION_HEADER_SUFFIX

    def _format_availability_status(self, consultant_db) -> str:
        """Formate le statut de disponibilit√© bas√© sur les missions"""
        # Utiliser la nouvelle logique de calcul dynamique
        status = _calculate_availability_status(consultant_db)

        if "Disponible dans" in status:
            # Format pour disponibilit√© future avec d√©lai
            return f"‚è≥ {status}\n\n"
        elif "Non disponible" in status:
            # Format pour indisponibilit√© avec alerte
            return f"üö´ {status}\n\n"
        else:
            # Format pour disponibilit√© imm√©diate
            return f"‚úÖ {status}\n\n"

    def _format_asap_availability(self, consultant_db) -> str:
        """Formate la disponibilit√© ASAP"""
        response = "‚úÖ **Disponible imm√©diatement (ASAP)**\n\n"
        missions_en_cours = self._get_missions_en_cours(consultant_db)

        if missions_en_cours:
            response += "‚ö†Ô∏è **Attention :** Le consultant a des missions en cours mais est marqu√© disponible\n"
            response += self._format_missions_list(missions_en_cours)

        return response

    def _format_planned_availability(self, consultant_db, date_dispo) -> str:
        """Formate la disponibilit√© planifi√©e"""
        response = "üìÖ **Disponible √† partir du :** " + str(date_dispo) + "\n\n"

        missions_futures = self._get_missions_futures(consultant_db)
        if missions_futures:
            response += "üéØ **Missions en cours/planifi√©es :**\n"
            response += self._format_missions_futures_list(missions_futures)

        return response

    def _get_missions_en_cours(self, consultant_db):
        """R√©cup√®re les missions en cours"""
        return [m for m in consultant_db.missions if m.statut == "en_cours"]

    def _get_missions_futures(self, consultant_db):
        """R√©cup√®re les missions futures"""
        from datetime import date

        return [m for m in consultant_db.missions if m.date_fin and m.date_fin > date.today()]

    def _format_missions_list(self, missions):
        """Formate la liste des missions"""
        result = ""
        for mission in missions:
            result += self.BULLET_POINT_INDENT + mission.nom_mission + " chez " + mission.client + "\n"
        return result

    def _format_missions_futures_list(self, missions):
        """Formate la liste des missions futures"""
        result = ""
        for mission in missions:
            fin_mission = mission.date_fin.strftime(self.DATE_FORMAT)
            result += self.BULLET_POINT_INDENT + mission.nom_mission + " (fin: " + fin_mission + ")\n"
        return result

    def _format_consultant_details(self, consultant_db) -> str:
        """Formate les d√©tails du consultant"""
        response = "\nüìä **Statut actuel :** "

        if consultant_db.disponibilite:
            response += "‚úÖ Marqu√© disponible"
        else:
            response += "üî¥ Marqu√© occup√©"

        if consultant_db.grade:
            response += "\nüéØ **Grade :** " + str(consultant_db.grade)
        if consultant_db.type_contrat:
            response += "\nüìù **Contrat :** " + str(consultant_db.type_contrat)

        return response

    def _format_availability_error(self, consultant) -> str:
        """Formate l'erreur de disponibilit√©"""
        return (
            "‚ùå Impossible de r√©cup√©rer les donn√©es de disponibilit√© pour **"
            + consultant.prenom
            + " "
            + consultant.nom
            + "**."
        )

    def _build_availability_result(self, consultant, consultant_db, response) -> Dict[str, Any]:
        """Construit le r√©sultat de disponibilit√©"""
        return {
            "response": response,
            "data": {
                "consultant": {
                    "nom": consultant.nom,
                    "prenom": consultant.prenom,
                    "date_disponibilite": (
                        getattr(consultant_db, "date_disponibilite", None) if consultant_db else None
                    ),
                    "disponibilite_immediate": (
                        getattr(consultant_db, "disponibilite", None) if consultant_db else None
                    ),
                }
            },
            "intent": "disponibilite",
            "confidence": 0.9,
        }

    def _build_availability_error_result(self, error) -> Dict[str, Any]:
        """Construit le r√©sultat d'erreur"""
        return {
            "response": ("‚ùå Erreur lors de la r√©cup√©ration des donn√©es de disponibilit√© : " + str(error)),
            "data": {},
            "intent": "disponibilite",
            "confidence": 0.3,
        }

    def _handle_general_availability_question(self) -> Dict[str, Any]:
        """G√®re les questions g√©n√©rales sur les disponibilit√©s"""
        try:
            consultants_dispos, consultants_occupes = self._get_availability_data()
            response = self._build_general_availability_response(consultants_dispos, consultants_occupes)

            return {
                "response": response,
                "data": {
                    "disponibles": len(consultants_dispos),
                    "occupes": len(consultants_occupes),
                    "total": len(consultants_dispos) + len(consultants_occupes),
                },
                "intent": "disponibilite",
                "confidence": 0.8,
            }

        except (SQLAlchemyError, AttributeError, ValueError, TypeError) as e:
            return {
                "response": "‚ùå Erreur lors de la r√©cup√©ration des disponibilit√©s : " + str(e),
                "data": {},
                "intent": "disponibilite",
                "confidence": 0.3,
            }

    def _get_availability_data(self):
        """R√©cup√®re les donn√©es de disponibilit√© g√©n√©rale"""
        with get_database_session() as session:
            consultants_dispos = session.query(Consultant).filter(Consultant.disponibilite).all()

        with get_database_session() as session:
            consultants_occupes = session.query(Consultant).filter(Consultant.disponibilite is False).all()

        return consultants_dispos, consultants_occupes

    def _build_general_availability_response(self, consultants_dispos, consultants_occupes) -> str:
        """Construit la r√©ponse g√©n√©rale de disponibilit√©"""
        response = "üìÖ **√âtat des disponibilit√©s** :\n\n"
        response += "‚úÖ **Disponibles imm√©diatement :** " + str(len(consultants_dispos)) + " consultant(s)\n"

        response += self._format_available_consultants_list(consultants_dispos)
        response += self._format_busy_consultants_section(consultants_occupes)

        return response

    def _format_available_consultants_list(self, consultants_dispos) -> str:
        """Formate la liste des consultants disponibles"""
        response = ""

        if consultants_dispos:
            for consultant in consultants_dispos[:5]:  # Limiter √† 5
                response += self.BULLET_POINT_INDENT + consultant.prenom + " " + consultant.nom + "\n"
            if len(consultants_dispos) > 5:
                response += self.BULLET_POINT_INDENT + "... et " + str(len(consultants_dispos) - 5) + " autre(s)\n"

        return response

    def _format_busy_consultants_section(self, consultants_occupes) -> str:
        """Formate la section des consultants occup√©s"""
        response = "\nüî¥ **Occup√©s :** " + str(len(consultants_occupes)) + " consultant(s)\n"

        if consultants_occupes:
            for consultant in consultants_occupes[:5]:  # Limiter √† 5
                date_dispo = consultant.date_disponibilite
                response += (
                    self.BULLET_POINT_INDENT
                    + consultant.prenom
                    + " "
                    + consultant.nom
                    + " (dispo: "
                    + str(date_dispo)
                    + ")\n"
                )
            if len(consultants_occupes) > 5:
                response += self.BULLET_POINT_INDENT + "... et " + str(len(consultants_occupes) - 5) + " autre(s)\n"

        return response

    def _get_consultant_missions_with_tjm(self, consultant_db) -> List:
        """R√©cup√®re les missions avec TJM d'un consultant"""
        if not consultant_db or not consultant_db.missions:
            return []
        return [m for m in consultant_db.missions if m.tjm or m.taux_journalier]

    def _format_mission_tjm_details(self, mission) -> str:
        """Formate les d√©tails d'une mission avec son TJM"""
        tjm = mission.tjm or mission.taux_journalier
        tjm_type = "TJM" if mission.tjm else "TJM (ancien)"

        response = f"üéØ **{mission.nom_mission}**\n"
        response += f"{self.BULLET_POINT_INDENT}Client: {mission.client}\n"
        response += f"{self.BULLET_POINT_INDENT}{tjm_type}: {tjm}‚Ç¨\n"

        if mission.date_debut:
            debut = mission.date_debut.strftime(self.DATE_FORMAT)
            if mission.date_fin:
                fin = mission.date_fin.strftime(self.DATE_FORMAT)
                response += f"{self.BULLET_POINT_INDENT}P√©riode: {debut} ‚Üí {fin}\n"
            else:
                response += f"{self.BULLET_POINT_INDENT}D√©but: {debut} (en cours)\n"

        return response + "\n"

    def _calculate_tjm_average(self, missions_avec_tjm) -> tuple:
        """Calcule le TJM moyen √† partir d'une liste de missions"""
        if not missions_avec_tjm:
            return 0, 0

        total_tjm = sum(mission.tjm or mission.taux_journalier for mission in missions_avec_tjm)
        count_tjm = len(missions_avec_tjm)
        return total_tjm / count_tjm if count_tjm > 0 else 0, count_tjm

    def _handle_consultant_tjm_inquiry(self, consultant) -> Dict[str, Any]:
        """G√®re les questions TJM pour un consultant sp√©cifique"""
        try:
            with get_database_session() as session:
                consultant_db = session.query(Consultant).filter(Consultant.id == consultant.id).first()

            missions_avec_tjm = self._get_consultant_missions_with_tjm(consultant_db)

            if missions_avec_tjm:
                response = f"üí∞ **TJM des missions de {consultant.prenom} {consultant.nom}** :\n\n"

                for mission in missions_avec_tjm:
                    response += self._format_mission_tjm_details(mission)

                tjm_moyen, count_tjm = self._calculate_tjm_average(missions_avec_tjm)
                if count_tjm > 1:
                    response += f"üìä **TJM moyen :** {tjm_moyen:.0f}‚Ç¨ (sur {count_tjm} missions)"

            else:
                response = f"üí∞ **{consultant.prenom} {consultant.nom}** : " "Aucun TJM renseign√© dans les missions"

        except (
            SQLAlchemyError,
            AttributeError,
            ValueError,
            TypeError,
            ZeroDivisionError,
        ) as e:
            response = f"‚ùå Erreur lors de la r√©cup√©ration des TJM : {str(e)}"

        return {
            "response": response,
            "data": {"consultant": {"nom": consultant.nom, "prenom": consultant.prenom}},
            "intent": "tjm_mission",
            "confidence": 0.9,
        }

    def _get_global_tjm_statistics(self) -> Dict[str, Any]:
        """Calcule les statistiques globales de TJM"""
        try:
            with get_database_session() as session:
                # TJM moyen avec nouveau champ
                tjm_nouveau_moyen = session.query(func.avg(Mission.tjm)).filter(Mission.tjm.isnot(None)).scalar() or 0

                # TJM moyen avec ancien champ
                tjm_ancien_moyen = (
                    session.query(func.avg(Mission.taux_journalier))
                    .filter(Mission.taux_journalier.isnot(None))
                    .scalar()
                    or 0
                )

                # Compter les missions avec TJM
                missions_nouveau_tjm = session.query(Mission).filter(Mission.tjm.isnot(None)).count()

                missions_ancien_tjm = session.query(Mission).filter(Mission.taux_journalier.isnot(None)).count()

            response = "üí∞ **Statistiques TJM des missions** :\n\n"

            if missions_nouveau_tjm > 0:
                response += "üÜï **Nouveau format TJM :**\n"
                response += f"{self.BULLET_POINT_INDENT}Missions avec TJM: {missions_nouveau_tjm}\n"
                response += f"{self.BULLET_POINT_INDENT}TJM moyen: {tjm_nouveau_moyen:.0f}‚Ç¨\n\n"

            if missions_ancien_tjm > 0:
                response += "üìä **Ancien format TJM :**\n"
                response += f"{self.BULLET_POINT_INDENT}Missions avec TJM: {missions_ancien_tjm}\n"
                response += f"{self.BULLET_POINT_INDENT}TJM moyen: {tjm_ancien_moyen:.0f}‚Ç¨\n\n"

            # Calcul global
            if missions_nouveau_tjm > 0 or missions_ancien_tjm > 0:
                total_missions = missions_nouveau_tjm + missions_ancien_tjm
                tjm_global = (
                    (tjm_nouveau_moyen * missions_nouveau_tjm) + (tjm_ancien_moyen * missions_ancien_tjm)
                ) / total_missions
                response += f"üéØ **TJM global moyen :** {tjm_global:.0f}‚Ç¨ (sur {total_missions} missions)"
            else:
                response = "üí∞ **Aucun TJM renseign√©** dans les missions"

            return {
                "response": response,
                "data": {
                    "tjm_nouveau_moyen": tjm_nouveau_moyen,
                    "tjm_ancien_moyen": tjm_ancien_moyen,
                    "missions_nouveau": missions_nouveau_tjm,
                    "missions_ancien": missions_ancien_tjm,
                },
                "intent": "tjm_mission",
                "confidence": 0.8,
            }

        except (SQLAlchemyError, ZeroDivisionError, TypeError, ValueError) as e:
            return {
                "response": f"‚ùå Erreur lors de la r√©cup√©ration des statistiques TJM : {str(e)}",
                "data": {},
                "intent": "tjm_mission",
                "confidence": 0.3,
            }

    def _handle_mission_tjm_question(self, entities: Dict) -> Dict[str, Any]:
        """
        G√®re les questions sur les TJM (Taux Journalier Moyen) des missions (V1.2.2).

        Analyse les TJM des missions d'un consultant sp√©cifique ou calcule
        les statistiques g√©n√©rales sur les TJM de toutes les missions.

        Args:
            entities: Dictionnaire contenant les entit√©s extraites de la question
                     (noms, entreprises, comp√©tences, langues, etc.)

        Returns:
            Dictionnaire contenant :
            - response: R√©ponse format√©e sur les TJM
            - data: Donn√©es structur√©es sur les TJM
            - intent: Type d'intention d√©tect√© ("tjm_mission")
            - confidence: Niveau de confiance de la r√©ponse (0.0 √† 1.0)
        """
        # Chercher un consultant sp√©cifique
        consultant = None
        if entities.get("noms"):
            nom_complet = " ".join(entities["noms"])
            consultant = self._find_consultant_by_name(nom_complet)

        if consultant:
            return self._handle_consultant_tjm_inquiry(consultant)
        else:
            return self._get_global_tjm_statistics()

    def get_response(self, question: str) -> str:
        """
        Interface simplifi√©e pour obtenir une r√©ponse textuelle du chatbot.

        M√©thode compatible avec les tests existants qui retourne uniquement
        la r√©ponse textuelle sans les m√©tadonn√©es structur√©es.

        Args:
            question: Question de l'utilisateur en langage naturel

        Returns:
            R√©ponse textuelle format√©e du chatbot, ou message d'erreur
            si la question n'est pas comprise ou en cas d'exception

        Raises:
            Aucun: Les exceptions sont captur√©es et retourn√©es comme messages d'erreur

        Example:
            >>> chatbot = ChatbotService()
            >>> response = chatbot.get_response("Quel est le salaire de Jean Dupont ?")
            >>> print(response)
            üí∞ Le salaire de **Jean Dupont** est de **45,000 ‚Ç¨** par an.

            >>> response = chatbot.get_response("Question incompr√©hensible")
            >>> print(response)
            ‚ùì Je n'ai pas compris votre question.
        """
        try:
            result = self.process_question(question)
            response = result.get("response", "‚ùì Je n'ai pas compris votre question.")
            return str(response) if response is not None else "‚ùì Je n'ai pas compris votre question."
        except (AttributeError, KeyError, TypeError, ValueError) as e:
            return "‚ùå Erreur: " + str(e)

    def __del__(self):
        """
        Destructeur de la classe ChatbotService.

        Nettoie les ressources utilis√©es par le service.
        Note: La gestion des sessions de base de donn√©es est d√©l√©gu√©e
        aux context managers pour √©viter les fuites de m√©moire.
        """
        # Nettoyage des ressources si n√©cessaire
        pass
